{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _typeof from 'babel-runtime/helpers/typeof';\n\nvar _class, _temp, _initialiseProps;\n\nimport { dom } from '../../util';\nimport findNode from './find-node';\nvar VIEWPORT = 'viewport'; // IE8 not support pageXOffset\n\nvar getPageX = function getPageX() {\n  return window.pageXOffset || document.documentElement.scrollLeft;\n};\n\nvar getPageY = function getPageY() {\n  return window.pageYOffset || document.documentElement.scrollTop;\n};\n/**\n * @private get element size\n * @param       {Element} element\n * @return      {Object}\n */\n\n\nfunction _getSize(element) {\n  // element like `svg` do not have offsetWidth and offsetHeight prop\n  // then getBoundingClientRect\n  if ('offsetWidth' in element && 'offsetHeight' in element) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  } else {\n    var _element$getBoundingC = element.getBoundingClientRect(),\n        width = _element$getBoundingC.width,\n        height = _element$getBoundingC.height;\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n}\n/**\n * @private get element rect\n * @param       {Element} elem\n * @return      {Object}\n */\n\n\nfunction _getElementRect(elem, container) {\n  var offsetTop = 0,\n      offsetLeft = 0,\n      scrollTop = 0,\n      scrollLeft = 0;\n\n  var _getSize2 = _getSize(elem),\n      width = _getSize2.width,\n      height = _getSize2.height;\n\n  do {\n    if (!isNaN(elem.offsetTop)) {\n      offsetTop += elem.offsetTop;\n    }\n\n    if (!isNaN(elem.offsetLeft)) {\n      offsetLeft += elem.offsetLeft;\n    }\n\n    if (elem && elem.offsetParent) {\n      if (!isNaN(elem.offsetParent.scrollLeft) && elem.offsetParent !== document.body) {\n        scrollLeft += elem.offsetParent.scrollLeft;\n      }\n\n      if (!isNaN(elem.offsetParent.scrollTop) && elem.offsetParent !== document.body) {\n        scrollTop += elem.offsetParent.scrollTop;\n      }\n    }\n\n    elem = elem.offsetParent;\n  } while (elem !== null && elem !== container); // if container is body or invalid, treat as window, use client width & height\n\n\n  var treatAsWindow = !container || container === document.body;\n  return {\n    top: offsetTop - scrollTop - (treatAsWindow ? document.documentElement.scrollTop || document.body.scrollTop : 0),\n    left: offsetLeft - scrollLeft - (treatAsWindow ? document.documentElement.scrollLeft || document.body.scrollLeft : 0),\n    width: width,\n    height: height\n  };\n}\n/**\n * @private get viewport size\n * @return {Object}\n */\n\n\nfunction _getViewportSize(container) {\n  if (!container || container === document.body) {\n    return {\n      width: document.documentElement.clientWidth,\n      height: document.documentElement.clientHeight\n    };\n  }\n\n  var _container$getBoundin = container.getBoundingClientRect(),\n      width = _container$getBoundin.width,\n      height = _container$getBoundin.height;\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nvar getContainer = function getContainer(_ref) {\n  var container = _ref.container,\n      baseElement = _ref.baseElement; // SSR下会有副作用\n\n  if ((typeof document === 'undefined' ? 'undefined' : _typeof(document)) === undefined) {\n    return container;\n  }\n\n  var calcContainer = findNode(container, baseElement);\n\n  if (!calcContainer) {\n    calcContainer = document.body;\n  }\n\n  while (dom.getStyle(calcContainer, 'position') === 'static') {\n    if (!calcContainer || calcContainer === document.body) {\n      return document.body;\n    }\n\n    calcContainer = calcContainer.parentNode;\n  }\n\n  return calcContainer;\n};\n\nvar Position = (_temp = _class = function () {\n  function Position(props) {\n    _classCallCheck(this, Position);\n\n    _initialiseProps.call(this);\n\n    this.pinElement = props.pinElement;\n    this.baseElement = props.baseElement;\n    this.pinFollowBaseElementWhenFixed = props.pinFollowBaseElementWhenFixed;\n    this.container = getContainer(props);\n    this.autoFit = props.autoFit || false;\n    this.align = props.align || 'tl tl';\n    this.offset = props.offset || [0, 0];\n    this.needAdjust = props.needAdjust || false;\n    this.isRtl = props.isRtl || false;\n  }\n  /**\n   * @public static place method\n   * @param  {Object}       props\n   *     @param  {DOM}      props.pinElement\n   *     @param  {DOM}      props.baseElement\n   *     @param  {String}   props.align\n   *     @param  {Number}   props.offset\n   *     @param  {Boolean}  props.needAdjust\n   *     @param  {Boolean}  props.isRtl\n   * @return {Position}\n   */\n\n\n  Position.prototype.setPosition = function setPosition() {\n    var pinElement = this.pinElement;\n    var baseElement = this.baseElement;\n    var pinFollowBaseElementWhenFixed = this.pinFollowBaseElementWhenFixed;\n\n    var expectedAlign = this._getExpectedAlign();\n\n    var isPinFixed = void 0,\n        isBaseFixed = void 0,\n        firstPositionResult = void 0;\n\n    if (pinElement === VIEWPORT) {\n      return;\n    }\n\n    if (dom.getStyle(pinElement, 'position') !== 'fixed') {\n      dom.setStyle(pinElement, 'position', 'absolute');\n      isPinFixed = false;\n    } else {\n      isPinFixed = true;\n    }\n\n    if (baseElement === VIEWPORT || dom.getStyle(baseElement, 'position') !== 'fixed') {\n      isBaseFixed = false;\n    } else {\n      isBaseFixed = true;\n    } // 根据期望的定位\n\n\n    for (var i = 0; i < expectedAlign.length; i++) {\n      var align = expectedAlign[i];\n\n      var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);\n\n      var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], // 忽略元素位置，发生在类似dialog的场景下\n      isPinFixed && !pinFollowBaseElementWhenFixed);\n\n      var pinElementParentOffset = this._getParentOffset(pinElement);\n\n      var pinElementParentScrollOffset = this._getParentScrollOffset(pinElement);\n\n      var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : // 在 pin 是 fixed 布局，并且又需要根据 base 计算位置时，计算 base 的 offset 需要忽略页面滚动\n      baseElementPoints.offset(isPinFixed && pinFollowBaseElementWhenFixed);\n      var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y + pinElementParentScrollOffset.top;\n      var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x + pinElementParentScrollOffset.left;\n\n      this._setPinElementPostion(pinElement, {\n        left: left,\n        top: top\n      }, this.offset);\n\n      if (this._isInViewport(pinElement, align)) {\n        return align;\n      } else if (!firstPositionResult) {\n        if (this.needAdjust && !this.autoFit) {\n          var _getViewportOffset2 = this._getViewportOffset(pinElement, align),\n              right = _getViewportOffset2.right;\n\n          firstPositionResult = {\n            left: right < 0 ? left + right : left,\n            top: top\n          };\n        } else {\n          firstPositionResult = {\n            left: left,\n            top: top\n          };\n        }\n      }\n    } // This will only execute if `pinElement` could not be placed entirely in the Viewport\n\n\n    var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);\n\n    var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);\n\n    this._setPinElementPostion(pinElement, {\n      left: inViewportLeft,\n      top: inViewportTop\n    }, this._calPinOffset(expectedAlign[0]));\n\n    return expectedAlign[0];\n  };\n\n  Position.prototype._getParentOffset = function _getParentOffset(element) {\n    var parent = element.offsetParent || document.documentElement;\n    var offset = void 0;\n\n    if (parent === document.body && dom.getStyle(parent, 'position') === 'static') {\n      offset = {\n        top: 0,\n        left: 0\n      };\n    } else {\n      offset = this._getElementOffset(parent);\n    }\n\n    offset.top += parseFloat(dom.getStyle(parent, 'border-top-width'), 10);\n    offset.left += parseFloat(dom.getStyle(parent, 'border-left-width'), 10);\n    offset.offsetParent = parent;\n    return offset;\n  };\n\n  Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {\n    // pinElement.offsetParent is never body because wrapper has position: absolute\n    // refactored to make code clearer. Revert if wrapper style changes.\n    var result = number;\n    var docElement = document.documentElement;\n    var offsetParent = pinElement.offsetParent || document.documentElement;\n\n    if (result < 0) {\n      if (isPinFixed) {\n        result = 0;\n      } else if (offsetParent === document.body && dom.getStyle(offsetParent, 'position') === 'static') {\n        // Only when div's offsetParent is document.body, we set new position result.\n        result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);\n      }\n    }\n\n    return result;\n  }; // 这里的第三个参数真实含义为：是否为fixed布局，并且像dialog一样，不跟随trigger元素\n\n\n  Position.prototype._normalizePosition = function _normalizePosition(element, align, ignoreElementOffset) {\n    var points = this._normalizeElement(element, ignoreElementOffset);\n\n    this._normalizeXY(points, align);\n\n    return points;\n  };\n\n  Position.prototype._normalizeXY = function _normalizeXY(points, align) {\n    var x = align.split('')[1];\n    var y = align.split('')[0];\n    points.x = this._xyConverter(x, points, 'width');\n    points.y = this._xyConverter(y, points, 'height');\n    return points;\n  };\n\n  Position.prototype._xyConverter = function _xyConverter(align, points, type) {\n    var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\\d+)%/gi, function (m, d) {\n      return points.size()[type] * (d / 100);\n    });\n    return parseFloat(res, 10) || 0;\n  };\n\n  Position.prototype._getLeftTop = function _getLeftTop(element) {\n    return {\n      left: parseFloat(dom.getStyle(element, 'left')) || 0,\n      top: parseFloat(dom.getStyle(element, 'top')) || 0\n    };\n  };\n\n  Position.prototype._normalizeElement = function _normalizeElement(element, ignoreElementOffset) {\n    var _this = this;\n\n    var result = {\n      element: element,\n      x: 0,\n      y: 0\n    },\n        isViewport = element === VIEWPORT,\n        docElement = document.documentElement;\n\n    result.offset = function (ignoreScroll) {\n      // 这里是关键，第二个参数的含义以ing该是：是否为 fixed 布局，并且像 dialog 一样，不跟随 trigger 元素\n      if (ignoreElementOffset) {\n        return {\n          left: 0,\n          top: 0\n        };\n      } else if (isViewport) {\n        return {\n          left: getPageX(),\n          top: getPageY()\n        };\n      } else {\n        return _this._getElementOffset(element, ignoreScroll);\n      }\n    };\n\n    result.size = function () {\n      if (isViewport) {\n        return {\n          width: docElement.clientWidth,\n          height: docElement.clientHeight\n        };\n      } else {\n        return _getSize(element);\n      }\n    };\n\n    return result;\n  }; // ignoreScroll 在 pin 元素为 fixed 的时候生效，此时需要忽略页面滚动\n  // 对 fixed 模式下 subNav 弹层的计算很重要，只有在这种情况下，才同时需要元素的相对位置，又不关心页面滚动\n\n\n  Position.prototype._getElementOffset = function _getElementOffset(element, ignoreScroll) {\n    var rect = element.getBoundingClientRect();\n    var docElement = document.documentElement;\n    var body = document.body;\n    var docClientLeft = docElement.clientLeft || body.clientLeft || 0;\n    var docClientTop = docElement.clientTop || body.clientTop || 0;\n    return {\n      left: rect.left + (ignoreScroll ? 0 : getPageX()) - docClientLeft,\n      top: rect.top + (ignoreScroll ? 0 : getPageY()) - docClientTop\n    };\n  }; // According to the location of the overflow to calculate the desired positioning\n\n\n  Position.prototype._getExpectedAlign = function _getExpectedAlign() {\n    var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, {\n      l: 'r',\n      r: 'l'\n    }) : this.align;\n    var expectedAlign = [align];\n\n    if (this.needAdjust) {\n      if (/t|b/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /t|b/g, {\n          t: 'b',\n          b: 't'\n        }));\n      }\n\n      if (/l|r/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /l|r/g, {\n          l: 'r',\n          r: 'l'\n        }));\n      }\n\n      if (/c/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'l'\n        }));\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'r'\n        }));\n      }\n\n      expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, {\n        l: 'r',\n        r: 'l',\n        t: 'b',\n        b: 't'\n      }));\n    }\n\n    return expectedAlign;\n  }; // Transform align order.\n\n\n  Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {\n    return align.replace(regExp, function (res) {\n      return map[res];\n    });\n  }; // Are the right sides of the pin and base aligned?\n\n\n  Position.prototype._isRightAligned = function _isRightAligned(align) {\n    var _align$split = align.split(' '),\n        pinAlign = _align$split[0],\n        baseAlign = _align$split[1];\n\n    return pinAlign[1] === 'r' && pinAlign[1] === baseAlign[1];\n  }; // Are the bottoms of the pin and base aligned?\n\n\n  Position.prototype._isBottomAligned = function _isBottomAligned(align) {\n    var _align$split2 = align.split(' '),\n        pinAlign = _align$split2[0],\n        baseAlign = _align$split2[1];\n\n    return pinAlign[0] === 'b' && pinAlign[0] === baseAlign[0];\n  }; // Detecting element is in the window， we want to adjust position later.\n\n\n  Position.prototype._isInViewport = function _isInViewport(element, align) {\n    var viewportSize = _getViewportSize(this.container);\n\n    var elementRect = _getElementRect(element, this.container);\n\n    var elementSize = _getSize(element); // https://github.com/alibaba-fusion/next/issues/853\n    // Equality causes issues in Chrome when pin element is off screen to right or bottom.\n    // If it is not supposed to align with the bottom or right, then subtract 1 to use strict less than.\n\n\n    var viewportWidth = this._isRightAligned(align) ? viewportSize.width : viewportSize.width - 1;\n    var viewportHeight = this._isBottomAligned(align) ? viewportSize.height : viewportSize.height - 1; // 临时方案，在 select + table 的场景下，不需要关注横向上是否在可视区域内\n    // 在 balloon 场景下需要关注\n\n    if (this.autoFit) {\n      return elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportHeight;\n    } // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.\n\n\n    return elementRect.left >= 0 && elementRect.left + elementSize.width <= viewportWidth && elementRect.top >= 0 && elementRect.top + elementSize.height <= viewportHeight;\n  };\n\n  Position.prototype._getViewportOffset = function _getViewportOffset(element, align) {\n    var viewportSize = _getViewportSize(this.container);\n\n    var elementRect = _getElementRect(element, this.container);\n\n    var elementSize = _getSize(element);\n\n    var viewportWidth = this._isRightAligned(align) ? viewportSize.width : viewportSize.width - 1;\n    var viewportHeight = this._isBottomAligned(align) ? viewportSize.height : viewportSize.height - 1;\n    return {\n      top: elementRect.top,\n      right: viewportWidth - (elementRect.left + elementSize.width),\n      bottom: viewportHeight - (elementRect.top + elementSize.height),\n      left: elementRect.left\n    };\n  }; // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位\n\n\n  Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n    var top = postion.top,\n        left = postion.left;\n\n    if (!this.isRtl) {\n      dom.setStyle(pinElement, {\n        left: left + offset[0] + 'px',\n        top: top + offset[1] + 'px'\n      });\n      return;\n    } // transfer {left,top} equaly to {right,top}\n\n\n    var pinElementParentOffset = this._getParentOffset(pinElement);\n\n    var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),\n        offsetParentWidth = _getElementRect2.width;\n\n    var _getElementRect3 = _getElementRect(pinElement),\n        width = _getElementRect3.width;\n\n    var right = offsetParentWidth - (left + width);\n    dom.setStyle(pinElement, {\n      left: 'auto',\n      right: right + offset[0] + 'px',\n      top: top + offset[1] + 'px'\n    });\n  };\n\n  return Position;\n}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {\n  return new Position(props).setPosition();\n}, _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._calPinOffset = function (align) {\n    var offset = [].concat(_this2.offset);\n\n    if (_this2.autoFit && align && _this2.container && _this2.container !== document.body) {\n      var baseElementRect = _getElementRect(_this2.baseElement, _this2.container);\n\n      var pinElementRect = _getElementRect(_this2.pinElement, _this2.container);\n\n      var viewportSize = _getViewportSize(_this2.container);\n\n      var pinAlign = align.split(' ')[0];\n      var x = pinAlign.charAt(1);\n      var y = pinAlign.charAt(0);\n\n      if (pinElementRect.top < 0 || pinElementRect.top + pinElementRect.height > viewportSize.height) {\n        offset[1] = -baseElementRect.top - (y === 't' ? baseElementRect.height : 0);\n      }\n    }\n\n    return offset;\n  };\n\n  this._getParentScrollOffset = function (elem) {\n    var top = 0;\n    var left = 0;\n\n    if (elem && elem.offsetParent && elem.offsetParent !== document.body) {\n      if (!isNaN(elem.offsetParent.scrollTop)) {\n        top += elem.offsetParent.scrollTop;\n      }\n\n      if (!isNaN(elem.offsetParent.scrollLeft)) {\n        left += elem.offsetParent.scrollLeft;\n      }\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n}, _temp);\nexport { Position as default };","map":{"version":3,"sources":["/Users/Chris/Project/lunch-order-backstage/node_modules/@alifd/next/es/overlay/utils/position.js"],"names":["_classCallCheck","_typeof","_class","_temp","_initialiseProps","dom","findNode","VIEWPORT","getPageX","window","pageXOffset","document","documentElement","scrollLeft","getPageY","pageYOffset","scrollTop","_getSize","element","width","offsetWidth","height","offsetHeight","_element$getBoundingC","getBoundingClientRect","_getElementRect","elem","container","offsetTop","offsetLeft","_getSize2","isNaN","offsetParent","body","treatAsWindow","top","left","_getViewportSize","clientWidth","clientHeight","_container$getBoundin","getContainer","_ref","baseElement","undefined","calcContainer","getStyle","parentNode","Position","props","call","pinElement","pinFollowBaseElementWhenFixed","autoFit","align","offset","needAdjust","isRtl","prototype","setPosition","expectedAlign","_getExpectedAlign","isPinFixed","isBaseFixed","firstPositionResult","setStyle","i","length","pinElementPoints","_normalizePosition","split","baseElementPoints","pinElementParentOffset","_getParentOffset","pinElementParentScrollOffset","_getParentScrollOffset","baseElementOffset","_getLeftTop","y","x","_setPinElementPostion","_isInViewport","_getViewportOffset2","_getViewportOffset","right","inViewportLeft","_makeElementInViewport","inViewportTop","_calPinOffset","parent","_getElementOffset","parseFloat","number","type","result","docElement","Math","max","ignoreElementOffset","points","_normalizeElement","_normalizeXY","_xyConverter","res","replace","m","d","size","_this","isViewport","ignoreScroll","rect","docClientLeft","clientLeft","docClientTop","clientTop","_replaceAlignDir","l","r","test","push","t","b","c","regExp","map","_isRightAligned","_align$split","pinAlign","baseAlign","_isBottomAligned","_align$split2","viewportSize","elementRect","elementSize","viewportWidth","viewportHeight","bottom","postion","arguments","_getElementRect2","offsetParentWidth","_getElementRect3","place","_this2","concat","baseElementRect","pinElementRect","charAt","default"],"mappings":"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","sourcesContent":["import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _typeof from 'babel-runtime/helpers/typeof';\n\nvar _class, _temp, _initialiseProps;\n\nimport { dom } from '../../util';\nimport findNode from './find-node';\n\nvar VIEWPORT = 'viewport';\n\n// IE8 not support pageXOffset\nvar getPageX = function getPageX() {\n    return window.pageXOffset || document.documentElement.scrollLeft;\n};\nvar getPageY = function getPageY() {\n    return window.pageYOffset || document.documentElement.scrollTop;\n};\n\n/**\n * @private get element size\n * @param       {Element} element\n * @return      {Object}\n */\nfunction _getSize(element) {\n    // element like `svg` do not have offsetWidth and offsetHeight prop\n    // then getBoundingClientRect\n    if ('offsetWidth' in element && 'offsetHeight' in element) {\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    } else {\n        var _element$getBoundingC = element.getBoundingClientRect(),\n            width = _element$getBoundingC.width,\n            height = _element$getBoundingC.height;\n\n        return {\n            width: width,\n            height: height\n        };\n    }\n}\n\n/**\n * @private get element rect\n * @param       {Element} elem\n * @return      {Object}\n */\nfunction _getElementRect(elem, container) {\n    var offsetTop = 0,\n        offsetLeft = 0,\n        scrollTop = 0,\n        scrollLeft = 0;\n\n    var _getSize2 = _getSize(elem),\n        width = _getSize2.width,\n        height = _getSize2.height;\n\n    do {\n        if (!isNaN(elem.offsetTop)) {\n            offsetTop += elem.offsetTop;\n        }\n        if (!isNaN(elem.offsetLeft)) {\n            offsetLeft += elem.offsetLeft;\n        }\n        if (elem && elem.offsetParent) {\n            if (!isNaN(elem.offsetParent.scrollLeft) && elem.offsetParent !== document.body) {\n                scrollLeft += elem.offsetParent.scrollLeft;\n            }\n\n            if (!isNaN(elem.offsetParent.scrollTop) && elem.offsetParent !== document.body) {\n                scrollTop += elem.offsetParent.scrollTop;\n            }\n        }\n\n        elem = elem.offsetParent;\n    } while (elem !== null && elem !== container);\n\n    // if container is body or invalid, treat as window, use client width & height\n    var treatAsWindow = !container || container === document.body;\n\n    return {\n        top: offsetTop - scrollTop - (treatAsWindow ? document.documentElement.scrollTop || document.body.scrollTop : 0),\n        left: offsetLeft - scrollLeft - (treatAsWindow ? document.documentElement.scrollLeft || document.body.scrollLeft : 0),\n        width: width,\n        height: height\n    };\n}\n\n/**\n * @private get viewport size\n * @return {Object}\n */\nfunction _getViewportSize(container) {\n    if (!container || container === document.body) {\n        return {\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight\n        };\n    }\n\n    var _container$getBoundin = container.getBoundingClientRect(),\n        width = _container$getBoundin.width,\n        height = _container$getBoundin.height;\n\n    return {\n        width: width,\n        height: height\n    };\n}\n\nvar getContainer = function getContainer(_ref) {\n    var container = _ref.container,\n        baseElement = _ref.baseElement;\n\n    // SSR下会有副作用\n    if ((typeof document === 'undefined' ? 'undefined' : _typeof(document)) === undefined) {\n        return container;\n    }\n\n    var calcContainer = findNode(container, baseElement);\n\n    if (!calcContainer) {\n        calcContainer = document.body;\n    }\n\n    while (dom.getStyle(calcContainer, 'position') === 'static') {\n        if (!calcContainer || calcContainer === document.body) {\n            return document.body;\n        }\n        calcContainer = calcContainer.parentNode;\n    }\n\n    return calcContainer;\n};\n\nvar Position = (_temp = _class = function () {\n    function Position(props) {\n        _classCallCheck(this, Position);\n\n        _initialiseProps.call(this);\n\n        this.pinElement = props.pinElement;\n        this.baseElement = props.baseElement;\n        this.pinFollowBaseElementWhenFixed = props.pinFollowBaseElementWhenFixed;\n        this.container = getContainer(props);\n        this.autoFit = props.autoFit || false;\n        this.align = props.align || 'tl tl';\n        this.offset = props.offset || [0, 0];\n        this.needAdjust = props.needAdjust || false;\n        this.isRtl = props.isRtl || false;\n    }\n\n    /**\n     * @public static place method\n     * @param  {Object}       props\n     *     @param  {DOM}      props.pinElement\n     *     @param  {DOM}      props.baseElement\n     *     @param  {String}   props.align\n     *     @param  {Number}   props.offset\n     *     @param  {Boolean}  props.needAdjust\n     *     @param  {Boolean}  props.isRtl\n     * @return {Position}\n     */\n\n\n    Position.prototype.setPosition = function setPosition() {\n        var pinElement = this.pinElement;\n        var baseElement = this.baseElement;\n        var pinFollowBaseElementWhenFixed = this.pinFollowBaseElementWhenFixed;\n        var expectedAlign = this._getExpectedAlign();\n        var isPinFixed = void 0,\n            isBaseFixed = void 0,\n            firstPositionResult = void 0;\n        if (pinElement === VIEWPORT) {\n            return;\n        }\n        if (dom.getStyle(pinElement, 'position') !== 'fixed') {\n            dom.setStyle(pinElement, 'position', 'absolute');\n            isPinFixed = false;\n        } else {\n            isPinFixed = true;\n        }\n        if (baseElement === VIEWPORT || dom.getStyle(baseElement, 'position') !== 'fixed') {\n            isBaseFixed = false;\n        } else {\n            isBaseFixed = true;\n        }\n\n        // 根据期望的定位\n        for (var i = 0; i < expectedAlign.length; i++) {\n            var align = expectedAlign[i];\n            var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);\n            var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1],\n            // 忽略元素位置，发生在类似dialog的场景下\n            isPinFixed && !pinFollowBaseElementWhenFixed);\n\n            var pinElementParentOffset = this._getParentOffset(pinElement);\n            var pinElementParentScrollOffset = this._getParentScrollOffset(pinElement);\n\n            var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : // 在 pin 是 fixed 布局，并且又需要根据 base 计算位置时，计算 base 的 offset 需要忽略页面滚动\n            baseElementPoints.offset(isPinFixed && pinFollowBaseElementWhenFixed);\n            var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y + pinElementParentScrollOffset.top;\n            var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x + pinElementParentScrollOffset.left;\n\n            this._setPinElementPostion(pinElement, { left: left, top: top }, this.offset);\n\n            if (this._isInViewport(pinElement, align)) {\n                return align;\n            } else if (!firstPositionResult) {\n                if (this.needAdjust && !this.autoFit) {\n                    var _getViewportOffset2 = this._getViewportOffset(pinElement, align),\n                        right = _getViewportOffset2.right;\n\n                    firstPositionResult = {\n                        left: right < 0 ? left + right : left,\n                        top: top\n                    };\n                } else {\n                    firstPositionResult = { left: left, top: top };\n                }\n            }\n        }\n\n        // This will only execute if `pinElement` could not be placed entirely in the Viewport\n        var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);\n        var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);\n\n        this._setPinElementPostion(pinElement, { left: inViewportLeft, top: inViewportTop }, this._calPinOffset(expectedAlign[0]));\n\n        return expectedAlign[0];\n    };\n\n    Position.prototype._getParentOffset = function _getParentOffset(element) {\n        var parent = element.offsetParent || document.documentElement;\n        var offset = void 0;\n        if (parent === document.body && dom.getStyle(parent, 'position') === 'static') {\n            offset = {\n                top: 0,\n                left: 0\n            };\n        } else {\n            offset = this._getElementOffset(parent);\n        }\n\n        offset.top += parseFloat(dom.getStyle(parent, 'border-top-width'), 10);\n        offset.left += parseFloat(dom.getStyle(parent, 'border-left-width'), 10);\n        offset.offsetParent = parent;\n        return offset;\n    };\n\n    Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {\n        // pinElement.offsetParent is never body because wrapper has position: absolute\n        // refactored to make code clearer. Revert if wrapper style changes.\n        var result = number;\n        var docElement = document.documentElement;\n        var offsetParent = pinElement.offsetParent || document.documentElement;\n\n        if (result < 0) {\n            if (isPinFixed) {\n                result = 0;\n            } else if (offsetParent === document.body && dom.getStyle(offsetParent, 'position') === 'static') {\n                // Only when div's offsetParent is document.body, we set new position result.\n                result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);\n            }\n        }\n        return result;\n    };\n\n    // 这里的第三个参数真实含义为：是否为fixed布局，并且像dialog一样，不跟随trigger元素\n\n\n    Position.prototype._normalizePosition = function _normalizePosition(element, align, ignoreElementOffset) {\n        var points = this._normalizeElement(element, ignoreElementOffset);\n        this._normalizeXY(points, align);\n\n        return points;\n    };\n\n    Position.prototype._normalizeXY = function _normalizeXY(points, align) {\n        var x = align.split('')[1];\n        var y = align.split('')[0];\n\n        points.x = this._xyConverter(x, points, 'width');\n        points.y = this._xyConverter(y, points, 'height');\n\n        return points;\n    };\n\n    Position.prototype._xyConverter = function _xyConverter(align, points, type) {\n        var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\\d+)%/gi, function (m, d) {\n            return points.size()[type] * (d / 100);\n        });\n\n        return parseFloat(res, 10) || 0;\n    };\n\n    Position.prototype._getLeftTop = function _getLeftTop(element) {\n        return {\n            left: parseFloat(dom.getStyle(element, 'left')) || 0,\n            top: parseFloat(dom.getStyle(element, 'top')) || 0\n        };\n    };\n\n    Position.prototype._normalizeElement = function _normalizeElement(element, ignoreElementOffset) {\n        var _this = this;\n\n        var result = {\n            element: element,\n            x: 0,\n            y: 0\n        },\n            isViewport = element === VIEWPORT,\n            docElement = document.documentElement;\n\n        result.offset = function (ignoreScroll) {\n            // 这里是关键，第二个参数的含义以ing该是：是否为 fixed 布局，并且像 dialog 一样，不跟随 trigger 元素\n            if (ignoreElementOffset) {\n                return {\n                    left: 0,\n                    top: 0\n                };\n            } else if (isViewport) {\n                return {\n                    left: getPageX(),\n                    top: getPageY()\n                };\n            } else {\n                return _this._getElementOffset(element, ignoreScroll);\n            }\n        };\n\n        result.size = function () {\n            if (isViewport) {\n                return {\n                    width: docElement.clientWidth,\n                    height: docElement.clientHeight\n                };\n            } else {\n                return _getSize(element);\n            }\n        };\n\n        return result;\n    };\n\n    // ignoreScroll 在 pin 元素为 fixed 的时候生效，此时需要忽略页面滚动\n    // 对 fixed 模式下 subNav 弹层的计算很重要，只有在这种情况下，才同时需要元素的相对位置，又不关心页面滚动\n\n\n    Position.prototype._getElementOffset = function _getElementOffset(element, ignoreScroll) {\n        var rect = element.getBoundingClientRect();\n        var docElement = document.documentElement;\n        var body = document.body;\n        var docClientLeft = docElement.clientLeft || body.clientLeft || 0;\n        var docClientTop = docElement.clientTop || body.clientTop || 0;\n\n        return {\n            left: rect.left + (ignoreScroll ? 0 : getPageX()) - docClientLeft,\n            top: rect.top + (ignoreScroll ? 0 : getPageY()) - docClientTop\n        };\n    };\n\n    // According to the location of the overflow to calculate the desired positioning\n\n\n    Position.prototype._getExpectedAlign = function _getExpectedAlign() {\n        var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' }) : this.align;\n        var expectedAlign = [align];\n        if (this.needAdjust) {\n            if (/t|b/g.test(align)) {\n                expectedAlign.push(this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' }));\n            }\n            if (/l|r/g.test(align)) {\n                expectedAlign.push(this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' }));\n            }\n            if (/c/g.test(align)) {\n                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' }));\n                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' }));\n            }\n            expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, {\n                l: 'r',\n                r: 'l',\n                t: 'b',\n                b: 't'\n            }));\n        }\n        return expectedAlign;\n    };\n\n    // Transform align order.\n\n\n    Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {\n        return align.replace(regExp, function (res) {\n            return map[res];\n        });\n    };\n\n    // Are the right sides of the pin and base aligned?\n\n\n    Position.prototype._isRightAligned = function _isRightAligned(align) {\n        var _align$split = align.split(' '),\n            pinAlign = _align$split[0],\n            baseAlign = _align$split[1];\n\n        return pinAlign[1] === 'r' && pinAlign[1] === baseAlign[1];\n    };\n\n    // Are the bottoms of the pin and base aligned?\n\n\n    Position.prototype._isBottomAligned = function _isBottomAligned(align) {\n        var _align$split2 = align.split(' '),\n            pinAlign = _align$split2[0],\n            baseAlign = _align$split2[1];\n\n        return pinAlign[0] === 'b' && pinAlign[0] === baseAlign[0];\n    };\n\n    // Detecting element is in the window， we want to adjust position later.\n\n\n    Position.prototype._isInViewport = function _isInViewport(element, align) {\n        var viewportSize = _getViewportSize(this.container);\n        var elementRect = _getElementRect(element, this.container);\n        var elementSize = _getSize(element);\n\n        // https://github.com/alibaba-fusion/next/issues/853\n        // Equality causes issues in Chrome when pin element is off screen to right or bottom.\n        // If it is not supposed to align with the bottom or right, then subtract 1 to use strict less than.\n        var viewportWidth = this._isRightAligned(align) ? viewportSize.width : viewportSize.width - 1;\n        var viewportHeight = this._isBottomAligned(align) ? viewportSize.height : viewportSize.height - 1;\n\n        // 临时方案，在 select + table 的场景下，不需要关注横向上是否在可视区域内\n        // 在 balloon 场景下需要关注\n        if (this.autoFit) {\n            return elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportHeight;\n        }\n\n        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.\n        return elementRect.left >= 0 && elementRect.left + elementSize.width <= viewportWidth && elementRect.top >= 0 && elementRect.top + elementSize.height <= viewportHeight;\n    };\n\n    Position.prototype._getViewportOffset = function _getViewportOffset(element, align) {\n        var viewportSize = _getViewportSize(this.container);\n        var elementRect = _getElementRect(element, this.container);\n        var elementSize = _getSize(element);\n\n        var viewportWidth = this._isRightAligned(align) ? viewportSize.width : viewportSize.width - 1;\n        var viewportHeight = this._isBottomAligned(align) ? viewportSize.height : viewportSize.height - 1;\n\n        return {\n            top: elementRect.top,\n            right: viewportWidth - (elementRect.left + elementSize.width),\n            bottom: viewportHeight - (elementRect.top + elementSize.height),\n            left: elementRect.left\n        };\n    };\n\n    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位\n\n\n    Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n        var top = postion.top,\n            left = postion.left;\n\n        if (!this.isRtl) {\n            dom.setStyle(pinElement, {\n                left: left + offset[0] + 'px',\n                top: top + offset[1] + 'px'\n            });\n            return;\n        }\n\n        // transfer {left,top} equaly to {right,top}\n        var pinElementParentOffset = this._getParentOffset(pinElement);\n\n        var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),\n            offsetParentWidth = _getElementRect2.width;\n\n        var _getElementRect3 = _getElementRect(pinElement),\n            width = _getElementRect3.width;\n\n        var right = offsetParentWidth - (left + width);\n        dom.setStyle(pinElement, {\n            left: 'auto',\n            right: right + offset[0] + 'px',\n            top: top + offset[1] + 'px'\n        });\n    };\n\n    return Position;\n}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {\n    return new Position(props).setPosition();\n}, _initialiseProps = function _initialiseProps() {\n    var _this2 = this;\n\n    this._calPinOffset = function (align) {\n        var offset = [].concat(_this2.offset);\n\n        if (_this2.autoFit && align && _this2.container && _this2.container !== document.body) {\n            var baseElementRect = _getElementRect(_this2.baseElement, _this2.container);\n            var pinElementRect = _getElementRect(_this2.pinElement, _this2.container);\n            var viewportSize = _getViewportSize(_this2.container);\n            var pinAlign = align.split(' ')[0];\n            var x = pinAlign.charAt(1);\n            var y = pinAlign.charAt(0);\n\n            if (pinElementRect.top < 0 || pinElementRect.top + pinElementRect.height > viewportSize.height) {\n                offset[1] = -baseElementRect.top - (y === 't' ? baseElementRect.height : 0);\n            }\n        }\n        return offset;\n    };\n\n    this._getParentScrollOffset = function (elem) {\n        var top = 0;\n        var left = 0;\n\n        if (elem && elem.offsetParent && elem.offsetParent !== document.body) {\n            if (!isNaN(elem.offsetParent.scrollTop)) {\n                top += elem.offsetParent.scrollTop;\n            }\n            if (!isNaN(elem.offsetParent.scrollLeft)) {\n                left += elem.offsetParent.scrollLeft;\n            }\n        }\n\n        return {\n            top: top,\n            left: left\n        };\n    };\n}, _temp);\nexport { Position as default };"]},"metadata":{},"sourceType":"module"}