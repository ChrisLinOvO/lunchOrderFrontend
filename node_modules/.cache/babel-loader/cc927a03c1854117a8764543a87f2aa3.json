{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _validate2 = _interopRequireDefault(require(\"@alifd/validate\"));\n\nvar _utils = require(\"./utils\");\n\nvar initMeta = {\n  state: '',\n  valueName: 'value',\n  trigger: 'onChange'\n};\n\nvar Field = /*#__PURE__*/function () {\n  function Field(com) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2.default)(this, Field);\n\n    if (!com) {\n      (0, _utils.warning)('`this` is missing in `Field`, you should use like `new Field(this)`');\n    }\n\n    this.com = com;\n    this.fieldsMeta = {};\n    this.cachedBind = {};\n    this.instance = {};\n    this.instanceCount = {}; // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.\n    // Also used caching values when using `parseName: true` before a field is initialized\n\n    this.values = (0, _extends2.default)({}, options.values);\n    this.processErrorMessage = options.processErrorMessage;\n    this.afterValidateRerender = options.afterValidateRerender;\n    this.options = (0, _extends2.default)({\n      parseName: false,\n      forceUpdate: false,\n      scrollToFirstError: true,\n      first: false,\n      onChange: function onChange() {},\n      autoUnmount: true,\n      autoValidate: true\n    }, options);\n    ['init', 'getValue', 'getValues', 'setValue', 'setValues', 'getError', 'getErrors', 'setError', 'setErrors', 'validateCallback', 'validatePromise', 'getState', 'reset', 'resetToDefault', 'remove', 'spliceArray', 'addArrayValue', 'deleteArrayValue', 'getNames'].forEach(function (m) {\n      _this[m] = _this[m].bind(_this);\n    });\n  }\n\n  (0, _createClass2.default)(Field, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      (0, _extends2.default)(this.options, options);\n    }\n    /**\n     * Controlled Component\n     * @param {String} name\n     * @param {Object} fieldOption\n     * @returns {Object} {value, onChange}\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(name) {\n      var _this2 = this;\n\n      var fieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rprops = arguments.length > 2 ? arguments[2] : undefined;\n      var id = fieldOption.id,\n          initValue = fieldOption.initValue,\n          _fieldOption$valueNam = fieldOption.valueName,\n          valueName = _fieldOption$valueNam === void 0 ? 'value' : _fieldOption$valueNam,\n          _fieldOption$trigger = fieldOption.trigger,\n          trigger = _fieldOption$trigger === void 0 ? 'onChange' : _fieldOption$trigger,\n          _fieldOption$rules = fieldOption.rules,\n          rules = _fieldOption$rules === void 0 ? [] : _fieldOption$rules,\n          _fieldOption$props = fieldOption.props,\n          props = _fieldOption$props === void 0 ? {} : _fieldOption$props,\n          _fieldOption$getValue = fieldOption.getValueFromEvent,\n          getValueFromEvent = _fieldOption$getValue === void 0 ? null : _fieldOption$getValue,\n          _fieldOption$getValue2 = fieldOption.getValueFormatter,\n          getValueFormatter = _fieldOption$getValue2 === void 0 ? getValueFromEvent : _fieldOption$getValue2,\n          setValueFormatter = fieldOption.setValueFormatter,\n          _fieldOption$autoVali = fieldOption.autoValidate,\n          autoValidate = _fieldOption$autoVali === void 0 ? true : _fieldOption$autoVali;\n      var parseName = this.options.parseName;\n\n      if (getValueFromEvent) {\n        (0, _utils.warning)('`getValueFromEvent` has been deprecated in `Field`, use `getValueFormatter` instead of it');\n      }\n\n      var originalProps = (0, _extends2.default)({}, props, rprops);\n      var defaultValueName = \"default\".concat(valueName[0].toUpperCase()).concat(valueName.slice(1));\n      var defaultValue;\n\n      if (typeof initValue !== 'undefined') {\n        defaultValue = initValue;\n      } else if (typeof originalProps[defaultValueName] !== 'undefined') {\n        // here use typeof, in case of defaultValue={0}\n        defaultValue = originalProps[defaultValueName];\n      } // get field from this.fieldsMeta or new one\n\n\n      var field = this._getInitMeta(name);\n\n      (0, _extends2.default)(field, {\n        valueName: valueName,\n        initValue: defaultValue,\n        disabled: 'disabled' in originalProps ? originalProps.disabled : false,\n        getValueFormatter: getValueFormatter,\n        setValueFormatter: setValueFormatter,\n        rules: Array.isArray(rules) ? rules : [rules],\n        ref: originalProps.ref\n      }); // Controlled Component, should always equal props.value\n\n      if (valueName in originalProps) {\n        field.value = originalProps[valueName]; // When rerendering set the values from props.value\n\n        if (parseName) {\n          this.values = (0, _utils.setIn)(this.values, name, field.value);\n        } else {\n          this.values[name] = field.value;\n        }\n      }\n      /**\n       * first init field (value not in field)\n       * should get field.value from this.values or defaultValue\n       */\n\n\n      if (!('value' in field)) {\n        if (parseName) {\n          var cachedValue = (0, _utils.getIn)(this.values, name);\n\n          if (typeof cachedValue !== 'undefined') {\n            field.value = cachedValue;\n          } else {\n            // save struct to this.values even defaultValue is undefiend\n            field.value = defaultValue;\n            this.values = (0, _utils.setIn)(this.values, name, field.value);\n          }\n        } else {\n          var _cachedValue = this.values[name];\n\n          if (typeof _cachedValue !== 'undefined') {\n            field.value = _cachedValue;\n          } else if (typeof defaultValue !== 'undefined') {\n            // should be same with parseName, but compatible with old versions\n            field.value = defaultValue;\n            this.values[name] = field.value;\n          }\n        }\n      } // Component props\n\n\n      var inputProps = (0, _defineProperty2.default)({\n        'data-meta': 'Field',\n        id: id || name,\n        ref: this._getCacheBind(name, \"\".concat(name, \"__ref\"), this._saveRef)\n      }, valueName, setValueFormatter ? setValueFormatter(field.value) : field.value);\n      var rulesMap = {};\n\n      if (this.options.autoValidate && autoValidate !== false) {\n        // trigger map in rules,\n        rulesMap = (0, _utils.mapValidateRules)(field.rules, trigger); // step1 : validate hooks\n\n        var _loop = function _loop(action) {\n          // skip default trigger, which will trigger in step2\n          if (action === trigger) {\n            return \"continue\";\n          }\n\n          var actionRule = rulesMap[action];\n\n          inputProps[action] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            _this2._callNativePropsEvent.apply(_this2, [action, originalProps].concat(args));\n\n            _this2._validate(name, actionRule, action);\n          };\n        };\n\n        for (var action in rulesMap) {\n          var _ret = _loop(action);\n\n          if (_ret === \"continue\") continue;\n        }\n      } // step2: onChange(trigger=onChange by default) hack\n\n\n      inputProps[trigger] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this2._updateFieldValue.apply(_this2, [name].concat(args)); // clear validate error\n\n\n        _this2._resetError(name);\n\n        _this2._callNativePropsEvent.apply(_this2, [trigger, originalProps].concat(args)); // call global onChange\n\n\n        _this2.options.onChange(name, field.value); // validate while onChange\n\n\n        var rule = rulesMap[trigger];\n        rule && _this2._validate(name, rule, trigger);\n\n        _this2._reRender();\n      };\n\n      delete originalProps[defaultValueName];\n      return (0, _extends2.default)({}, originalProps, inputProps);\n    }\n    /**\n     * call native event from props.onXx\n     * eg: props.onChange props.onBlur props.onFocus\n     */\n\n  }, {\n    key: \"_callNativePropsEvent\",\n    value: function _callNativePropsEvent(action, props) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      action in props && typeof props[action] === 'function' && props[action].apply(props, args);\n    }\n  }, {\n    key: \"_getInitMeta\",\n    value: function _getInitMeta(name) {\n      if (!(name in this.fieldsMeta)) {\n        this.fieldsMeta[name] = (0, _extends2.default)({}, initMeta);\n      }\n\n      return this.fieldsMeta[name];\n    }\n    /**\n     * update field.value and validate\n     */\n\n  }, {\n    key: \"_updateFieldValue\",\n    value: function _updateFieldValue(name) {\n      for (var _len4 = arguments.length, others = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        others[_key4 - 1] = arguments[_key4];\n      }\n\n      var e = others[0];\n\n      var field = this._get(name);\n\n      if (!field) {\n        return;\n      }\n\n      field.value = field.getValueFormatter ? field.getValueFormatter.apply(this, others) : (0, _utils.getValueFromEvent)(e);\n\n      if (this.options.parseName) {\n        this.values = (0, _utils.setIn)(this.values, name, field.value);\n      } else {\n        this.values[name] = field.value;\n      }\n    }\n    /**\n     * ref must always be the same function, or if not it will be triggerd every time.\n     * @param {String} name name of component\n     * @param {String} action key to find ref\n     * @param {Function} fn saveRef\n     */\n\n  }, {\n    key: \"_getCacheBind\",\n    value: function _getCacheBind(name, action, fn) {\n      var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n\n      if (!cache[action]) {\n        cache[action] = fn.bind(this, name);\n      }\n\n      return cache[action];\n    }\n  }, {\n    key: \"_setCache\",\n    value: function _setCache(name, action, hander) {\n      var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n      cache[action] = hander;\n    }\n  }, {\n    key: \"_getCache\",\n    value: function _getCache(name, action) {\n      var cache = this.cachedBind[name] || {};\n      return cache[action];\n    }\n    /**\n     * NOTE: saveRef is async function. it will be called after render\n     * @param {String} name name of component\n     * @param {Function} component ref\n     */\n\n  }, {\n    key: \"_saveRef\",\n    value: function _saveRef(name, component) {\n      var key = \"\".concat(name, \"_field\");\n      var autoUnmount = this.options.autoUnmount;\n\n      if (!component && autoUnmount) {\n        // more than one component, do nothing\n        this.instanceCount[name] && this.instanceCount[name]--;\n\n        if (this.instanceCount[name] > 0) {\n          return;\n        } // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)\n        // while type changed, B will render before A unmount. so we should cached value for B\n        // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render\n        // 1. _saveRef(A, null)\n\n\n        var cache = this.fieldsMeta[name];\n        cache && this._setCache(name, key, cache); // after destroy, delete data\n\n        delete this.instance[name];\n        this.remove(name);\n        return;\n      } // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)\n\n\n      if (autoUnmount && !this.fieldsMeta[name] && this._getCache(name, key)) {\n        this.fieldsMeta[name] = this._getCache(name, key);\n        this.setValue(name, this.fieldsMeta[name] && this.fieldsMeta[name].value, false);\n      } // only one time here\n\n\n      var field = this._get(name);\n\n      if (field) {\n        var ref = field.ref;\n\n        if (ref) {\n          if (typeof ref === 'string') {\n            throw new Error(\"can not set string ref for \".concat(name));\n          } else if (typeof ref === 'function') {\n            ref(component);\n          } else if ((0, _typeof2.default)(ref) === 'object' && 'current' in ref) {\n            // while ref = React.createRef() ref={ current: null}\n            ref.current = component;\n          }\n        } // mount\n\n\n        if (autoUnmount && component) {\n          var cnt = this.instanceCount[name];\n\n          if (!cnt) {\n            cnt = 0;\n          }\n\n          this.instanceCount[name] = cnt + 1;\n        }\n\n        this.instance[name] = component;\n      }\n    }\n    /**\n     * validate one Component\n     * @param {String} name name of Component\n     * @param {Array} rule\n     * @param {String} trigger onChange/onBlur/onItemClick/...\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate(name, rule, trigger) {\n      var _this3 = this;\n\n      var field = this._get(name);\n\n      if (!field) {\n        return;\n      }\n\n      var value = field.value;\n      field.state = 'loading';\n\n      var validate = this._getCache(name, trigger);\n\n      if (validate && typeof validate.abort === 'function') {\n        validate.abort();\n      }\n\n      validate = new _validate2.default((0, _defineProperty2.default)({}, name, rule), {\n        messages: this.options.messages\n      });\n\n      this._setCache(name, trigger, validate);\n\n      validate.validate((0, _defineProperty2.default)({}, name, value), function (errors) {\n        var newErrors, newState;\n\n        if (errors && errors.length) {\n          newErrors = (0, _utils.getErrorStrs)(errors, _this3.processErrorMessage);\n          newState = 'error';\n        } else {\n          newErrors = [];\n          newState = 'success';\n        }\n\n        var reRender = false; // only status or errors changed, Rerender\n\n        if (newState !== field.state || !field.errors || newErrors.length !== field.errors.length || newErrors.find(function (e, idx) {\n          return e !== field.errors[idx];\n        })) {\n          reRender = true;\n        }\n\n        field.errors = newErrors;\n        field.state = newState;\n        reRender && _this3._reRender();\n      });\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(name) {\n      if (this.options.parseName) {\n        return (0, _utils.getIn)(this.values, name);\n      }\n\n      return this.values[name];\n    }\n    /**\n     * 1. get values by names.\n     * 2. If no names passed, return shallow copy of `field.values`\n     * @param {Array} names\n     */\n\n  }, {\n    key: \"getValues\",\n    value: function getValues(names) {\n      var _this4 = this;\n\n      var allValues = {};\n\n      if (names && names.length) {\n        names.forEach(function (name) {\n          allValues[name] = _this4.getValue(name);\n        });\n      } else {\n        (0, _extends2.default)(allValues, this.values);\n      }\n\n      return allValues;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(name, value) {\n      var reRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (name in this.fieldsMeta) {\n        this.fieldsMeta[name].value = value;\n      }\n\n      if (this.options.parseName) {\n        this.values = (0, _utils.setIn)(this.values, name, value);\n      } else {\n        this.values[name] = value;\n      }\n\n      reRender && this._reRender();\n    }\n  }, {\n    key: \"setValues\",\n    value: function setValues() {\n      var _this5 = this;\n\n      var fieldsValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.options.parseName) {\n        Object.keys(fieldsValue).forEach(function (name) {\n          _this5.setValue(name, fieldsValue[name], false);\n        });\n      } else {\n        // NOTE: this is a shallow merge\n        // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}\n        this.values = (0, _extends2.default)({}, this.values, fieldsValue);\n        var fields = this.getNames();\n        fields.forEach(function (name) {\n          var value = (0, _utils.getIn)(_this5.values, name);\n\n          if (value !== undefined) {\n            // copy over values that are in this.values\n            _this5.fieldsMeta[name].value = value;\n          } else {\n            // because of shallow merge\n            // if no value then copy values from fieldsMeta to keep initialized component data\n            _this5.values = (0, _utils.setIn)(_this5.values, name, _this5.fieldsMeta[name].value);\n          }\n        });\n      }\n\n      reRender && this._reRender();\n    }\n  }, {\n    key: \"setError\",\n    value: function setError(name, errors) {\n      var err = Array.isArray(errors) ? errors : errors ? [errors] : [];\n\n      if (name in this.fieldsMeta) {\n        this.fieldsMeta[name].errors = err;\n      } else {\n        this.fieldsMeta[name] = {\n          errors: err\n        };\n      }\n\n      if (this.fieldsMeta[name].errors && this.fieldsMeta[name].errors.length > 0) {\n        this.fieldsMeta[name].state = 'error';\n      } else {\n        this.fieldsMeta[name].state = '';\n      }\n\n      this._reRender();\n    }\n  }, {\n    key: \"setErrors\",\n    value: function setErrors() {\n      var _this6 = this;\n\n      var fieldsErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(fieldsErrors).forEach(function (name) {\n        _this6.setError(name, fieldsErrors[name]);\n      });\n    }\n  }, {\n    key: \"getError\",\n    value: function getError(name) {\n      var field = this._get(name);\n\n      if (field && field.errors && field.errors.length) {\n        return field.errors;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getErrors\",\n    value: function getErrors(names) {\n      var _this7 = this;\n\n      var fields = names || this.getNames();\n      var allErrors = {};\n      fields.forEach(function (f) {\n        allErrors[f] = _this7.getError(f);\n      });\n      return allErrors;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState(name) {\n      var field = this._get(name);\n\n      if (field && field.state) {\n        return field.state;\n      }\n\n      return '';\n    }\n    /**\n     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate\n     * @param {Array} fieldNames\n     * @return {Object || null} map of inputs and their errors\n     */\n\n  }, {\n    key: \"formatGetErrors\",\n    value: function formatGetErrors(fieldNames) {\n      var errors = this.getErrors(fieldNames);\n      var formattedErrors = null;\n\n      for (var field in errors) {\n        if (errors.hasOwnProperty(field) && errors[field]) {\n          var errorsObj = errors[field];\n\n          if (!formattedErrors) {\n            formattedErrors = {};\n          }\n\n          formattedErrors[field] = {\n            errors: errorsObj\n          };\n        }\n      }\n\n      return formattedErrors;\n    }\n    /**\n     * validate by trigger\n     * @param {Array} ns names\n     * @param {Function} cb callback after validate\n     */\n\n  }, {\n    key: \"validateCallback\",\n    value: function validateCallback(ns, cb) {\n      var _this8 = this;\n\n      var _getParams = (0, _utils.getParams)(ns, cb),\n          names = _getParams.names,\n          callback = _getParams.callback;\n\n      var fieldNames = names || this.getNames();\n      var descriptor = {};\n      var values = {};\n      var hasRule = false;\n\n      for (var i = 0; i < fieldNames.length; i++) {\n        var name = fieldNames[i];\n\n        var field = this._get(name);\n\n        if (!field) {\n          continue;\n        }\n\n        if (field.rules && field.rules.length) {\n          descriptor[name] = field.rules;\n          values[name] = this.getValue(name);\n          hasRule = true; // clear error\n\n          field.errors = [];\n          field.state = '';\n        }\n      }\n\n      if (!hasRule) {\n        var errors = this.formatGetErrors(fieldNames);\n        callback && callback(errors, this.getValues(names ? fieldNames : []));\n        return;\n      }\n\n      var validate = new _validate2.default(descriptor, {\n        first: this.options.first,\n        messages: this.options.messages\n      });\n      validate.validate(values, function (errors) {\n        var errorsGroup = null;\n\n        if (errors && errors.length) {\n          errorsGroup = {};\n          errors.forEach(function (e) {\n            var fieldName = e.field;\n\n            if (!errorsGroup[fieldName]) {\n              errorsGroup[fieldName] = {\n                errors: []\n              };\n            }\n\n            var fieldErrors = errorsGroup[fieldName].errors;\n            fieldErrors.push(e.message);\n          });\n        }\n\n        if (errorsGroup) {\n          // update error in every Field\n          Object.keys(errorsGroup).forEach(function (i) {\n            var field = _this8._get(i);\n\n            if (field) {\n              field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this8.processErrorMessage);\n              field.state = 'error';\n            }\n          });\n        }\n\n        var formattedGetErrors = _this8.formatGetErrors(fieldNames);\n\n        if (formattedGetErrors) {\n          errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);\n        } // update to success which has no error\n\n\n        for (var _i = 0; _i < fieldNames.length; _i++) {\n          var _name = fieldNames[_i];\n\n          var _field = _this8._get(_name);\n\n          if (_field && _field.rules && !(errorsGroup && _name in errorsGroup)) {\n            _field.state = 'success';\n          }\n        } // eslint-disable-next-line callback-return\n\n\n        callback && callback(errorsGroup, _this8.getValues(names ? fieldNames : []));\n\n        _this8._reRender();\n\n        if (typeof _this8.afterValidateRerender === 'function') {\n          _this8.afterValidateRerender({\n            errorsGroup: errorsGroup,\n            options: _this8.options,\n            instance: _this8.instance\n          });\n        }\n      });\n    }\n    /**\n     * validate by trigger - Promise version\n     * NOTES:\n     * - `afterValidateRerender` is not called in `validatePromise`. The rerender is called just before this function\n     *      returns a promise, so use the returned promise to call any after rerender logic.\n     *\n     * @param {Array} ns names\n     * @param {Function} cb (Optional) callback after validate, must return a promise or a value\n     *                  - ({errors, values}) => Promise({errors, values}) | {errors, values}\n     * @returns {Promise} - resolves with {errors, values}\n     */\n\n  }, {\n    key: \"validatePromise\",\n    value: function () {\n      var _validatePromise = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(ns, cb) {\n        var _getParams2, names, callback, fieldNames, descriptor, values, hasRule, i, name, field, _errors, validate, results, errors, errorsGroup, callbackResults;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _getParams2 = (0, _utils.getParams)(ns, cb), names = _getParams2.names, callback = _getParams2.callback;\n                fieldNames = names || this.getNames();\n                descriptor = {};\n                values = {};\n                hasRule = false;\n                i = 0;\n\n              case 6:\n                if (!(i < fieldNames.length)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                name = fieldNames[i];\n                field = this._get(name);\n\n                if (field) {\n                  _context.next = 11;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 12);\n\n              case 11:\n                if (field.rules && field.rules.length) {\n                  descriptor[name] = field.rules;\n                  values[name] = this.getValue(name);\n                  hasRule = true; // clear error\n\n                  field.errors = [];\n                  field.state = '';\n                }\n\n              case 12:\n                i++;\n                _context.next = 6;\n                break;\n\n              case 15:\n                if (hasRule) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _errors = this.formatGetErrors(fieldNames);\n\n                if (!callback) {\n                  _context.next = 21;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", callback({\n                  errors: _errors,\n                  values: this.getValues(names ? fieldNames : [])\n                }));\n\n              case 21:\n                return _context.abrupt(\"return\", {\n                  errors: _errors,\n                  values: this.getValues(names ? fieldNames : [])\n                });\n\n              case 22:\n                validate = new _validate2.default(descriptor, {\n                  first: this.options.first,\n                  messages: this.options.messages\n                });\n                _context.next = 25;\n                return validate.validatePromise(values);\n\n              case 25:\n                results = _context.sent;\n                errors = results && results.errors || [];\n                errorsGroup = this._getErrorsGroup({\n                  errors: errors,\n                  fieldNames: fieldNames\n                });\n                callbackResults = {\n                  errors: errorsGroup,\n                  values: this.getValues(names ? fieldNames : [])\n                };\n                _context.prev = 29;\n\n                if (!callback) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _context.next = 33;\n                return callback(callbackResults);\n\n              case 33:\n                callbackResults = _context.sent;\n\n              case 34:\n                _context.next = 39;\n                break;\n\n              case 36:\n                _context.prev = 36;\n                _context.t0 = _context[\"catch\"](29);\n                return _context.abrupt(\"return\", _context.t0);\n\n              case 39:\n                this._reRender();\n\n                return _context.abrupt(\"return\", callbackResults);\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[29, 36]]);\n      }));\n\n      function validatePromise(_x, _x2) {\n        return _validatePromise.apply(this, arguments);\n      }\n\n      return validatePromise;\n    }()\n  }, {\n    key: \"_getErrorsGroup\",\n    value: function _getErrorsGroup(_ref) {\n      var _this9 = this;\n\n      var errors = _ref.errors,\n          fieldNames = _ref.fieldNames;\n      var errorsGroup = null;\n\n      if (errors && errors.length) {\n        errorsGroup = {};\n        errors.forEach(function (e) {\n          var fieldName = e.field;\n\n          if (!errorsGroup[fieldName]) {\n            errorsGroup[fieldName] = {\n              errors: []\n            };\n          }\n\n          var fieldErrors = errorsGroup[fieldName].errors;\n          fieldErrors.push(e.message);\n        });\n      }\n\n      if (errorsGroup) {\n        // update error in every Field\n        Object.keys(errorsGroup).forEach(function (i) {\n          var field = _this9._get(i);\n\n          if (field) {\n            field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this9.processErrorMessage);\n            field.state = 'error';\n          }\n        });\n      }\n\n      var formattedGetErrors = this.formatGetErrors(fieldNames);\n\n      if (formattedGetErrors) {\n        errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);\n      } // update to success which has no error\n\n\n      for (var i = 0; i < fieldNames.length; i++) {\n        var name = fieldNames[i];\n\n        var field = this._get(name);\n\n        if (field && field.rules && !(errorsGroup && name in errorsGroup)) {\n          field.state = 'success';\n        }\n      }\n\n      return errorsGroup;\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(ns, backToDefault) {\n      var _this10 = this;\n\n      if (typeof ns === 'string') {\n        ns = [ns];\n      }\n\n      var changed = false;\n      var names = ns || Object.keys(this.fieldsMeta);\n\n      if (!ns) {\n        this.values = {};\n      }\n\n      names.forEach(function (name) {\n        var field = _this10._get(name);\n\n        if (field) {\n          changed = true;\n          field.value = backToDefault ? field.initValue : undefined;\n          field.state = '';\n          delete field.errors;\n          delete field.rules;\n          delete field.rulesMap;\n\n          if (_this10.options.parseName) {\n            _this10.values = (0, _utils.setIn)(_this10.values, name, field.value);\n          } else {\n            _this10.values[name] = field.value;\n          }\n        }\n      });\n\n      if (changed) {\n        this._reRender();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(ns) {\n      this._reset(ns, false);\n    }\n  }, {\n    key: \"resetToDefault\",\n    value: function resetToDefault(ns) {\n      this._reset(ns, true);\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      var fieldsMeta = this.fieldsMeta;\n      return Object.keys(fieldsMeta).filter(function () {\n        return true;\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ns) {\n      var _this11 = this;\n\n      if (typeof ns === 'string') {\n        ns = [ns];\n      }\n\n      if (!ns) {\n        this.values = {};\n      }\n\n      var names = ns || Object.keys(this.fieldsMeta);\n      names.forEach(function (name) {\n        if (name in _this11.fieldsMeta) {\n          delete _this11.fieldsMeta[name];\n        }\n\n        if (_this11.options.parseName) {\n          _this11.values = (0, _utils.deleteIn)(_this11.values, name);\n        } else {\n          delete _this11.values[name];\n        }\n      });\n    }\n  }, {\n    key: \"addArrayValue\",\n    value: function addArrayValue(key, index) {\n      for (var _len5 = arguments.length, argv = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        argv[_key5 - 2] = arguments[_key5];\n      }\n\n      return this._spliceArrayValue.apply(this, [key, index, 0].concat(argv));\n    }\n  }, {\n    key: \"deleteArrayValue\",\n    value: function deleteArrayValue(key, index) {\n      var howmany = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return this._spliceArrayValue(key, index, howmany);\n    }\n    /**\n     * splice array\n     * @param {String} key\n     * @param {Number} startIndex\n     * @param {Number} howmany\n     * @param {Array} argv\n     * @param {*} value\n     */\n\n  }, {\n    key: \"_spliceArrayValue\",\n    value: function _spliceArrayValue(key, index, howmany) {\n      var _this12 = this;\n\n      for (var _len6 = arguments.length, argv = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n        argv[_key6 - 3] = arguments[_key6];\n      }\n\n      var argc = argv.length;\n      var offset = howmany - argc; // how the reset fieldMeta move\n\n      var startIndex = index + howmany; // 计算起点\n\n      /**\n       * eg: call _spliceArrayValue('key', 1) to delete 'key.1':\n       *   case 1: names=['key.0', 'key.1']; delete 'key.1';\n       *   case 2: names=['key.0', 'key.1', 'key.2']; key.1= key.2; delete key.2;\n       *   case 3: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'\n       * eg: call _spliceArrayValue('key', 1, item) to add 'key.1':\n       *   case 1: names=['key.0']; add 'key.1' = item;\n       *   case 2: names=['key.0', 'key.1']; key.2= key.1; delete key.1; add key.1 = item;\n       */\n\n      var listMap = {}; // eg: {1:[{from: 'key.2.name', to: 'key.1.name'}, {from: 'key.2.email', to: 'key.1.email'}]}\n\n      var keyReg = new RegExp(\"^(\".concat(key, \".)(\\\\d+)\"));\n      var replaceArgv = [];\n      var names = this.getNames(); // logic of offset fix begin\n\n      names.forEach(function (n) {\n        var ret = keyReg.exec(n);\n\n        if (ret) {\n          var idx = parseInt(ret[2]); // get index of 'key.0.name'\n\n          if (idx >= startIndex) {\n            var l = listMap[idx];\n            var item = {\n              from: n,\n              to: n.replace(keyReg, function (match, p1) {\n                return \"\".concat(p1).concat(idx - offset);\n              })\n            };\n\n            if (!l) {\n              listMap[idx] = [item];\n            } else {\n              l.push(item);\n            }\n          } // in case of offsetList.length = 0, eg: delete last element\n\n\n          if (offset > 0 && idx >= index && idx < index + howmany) {\n            replaceArgv.push(n);\n          }\n        }\n      }); // sort with index eg: [{index:1, list: [{from: 'key.2.name', to: 'key.1.name'}]}, {index:2, list: [...]}]\n\n      var offsetList = Object.keys(listMap).map(function (i) {\n        return {\n          index: Number(i),\n          list: listMap[i]\n        };\n      }).sort(function (a, b) {\n        return offset > 0 ? a.index - b.index : b.index - a.index;\n      });\n      offsetList.forEach(function (l) {\n        var list = l.list;\n        list.forEach(function (i) {\n          _this12.fieldsMeta[i.to] = _this12.fieldsMeta[i.from];\n        });\n      }); // delete copy data\n\n      if (offsetList.length > 0) {\n        var removeList = offsetList.slice(offsetList.length - (offset < 0 ? -offset : offset), offsetList.length);\n        removeList.forEach(function (item) {\n          item.list.forEach(function (i) {\n            delete _this12.fieldsMeta[i.from];\n          });\n        });\n      } else {\n        // will get from this.values while rerender\n        replaceArgv.forEach(function (i) {\n          delete _this12.fieldsMeta[i];\n        });\n      }\n\n      var p = this.getValue(key);\n\n      if (p) {\n        p.splice.apply(p, [index, howmany].concat(argv));\n      }\n\n      this._reRender();\n    }\n    /**\n     * splice in a Array [deprecated]\n     * @param {String} keyMatch like name.{index}\n     * @param {Number} startIndex index\n     */\n\n  }, {\n    key: \"spliceArray\",\n    value: function spliceArray(keyMatch, startIndex, howmany) {\n      var _this13 = this;\n\n      if (keyMatch.match(/{index}$/) === -1) {\n        (0, _utils.warning)('key should match /{index}$/');\n        return;\n      } // regex to match field names in the same target array\n\n\n      var reg = keyMatch.replace('{index}', '(\\\\d+)');\n      var keyReg = new RegExp(\"^\".concat(reg));\n      var listMap = {};\n      /**\n       * keyMatch='key.{index}'\n       * case 1: names=['key.0', 'key.1'], should delete 'key.1'\n       * case 2: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'\n       */\n\n      var names = this.getNames();\n      names.forEach(function (n) {\n        // is name in the target array?\n        var ret = keyReg.exec(n);\n\n        if (ret) {\n          var index = parseInt(ret[1]);\n\n          if (index > startIndex) {\n            var l = listMap[index];\n            var item = {\n              from: n,\n              to: \"\".concat(keyMatch.replace('{index}', index - 1)).concat(n.replace(ret[0], ''))\n            };\n\n            if (!l) {\n              listMap[index] = [item];\n            } else {\n              l.push(item);\n            }\n          }\n        }\n      });\n      var idxList = Object.keys(listMap).map(function (i) {\n        return {\n          index: Number(i),\n          list: listMap[i]\n        };\n      }).sort(function (a, b) {\n        return a.index < b.index;\n      }); // should be continuous array\n\n      if (idxList.length > 0 && idxList[0].index === startIndex + 1) {\n        idxList.forEach(function (l) {\n          var list = l.list;\n          list.forEach(function (i) {\n            var v = _this13.getValue(i.from); // get index value\n\n\n            _this13.setValue(i.to, v, false); // set value to index - 1\n\n          });\n        });\n        var lastIdxList = idxList[idxList.length - 1];\n        lastIdxList.list.forEach(function (i) {\n          _this13.remove(i.from);\n        });\n        var parentName = keyMatch.replace('.{index}', '');\n        parentName = parentName.replace('[{index}]', '');\n        var parent = this.getValue(parentName);\n\n        if (parent) {\n          // if parseName=true then parent is an Array object but does not know an element was removed\n          // this manually decrements the array length\n          parent.length--;\n        }\n      }\n    }\n  }, {\n    key: \"_resetError\",\n    value: function _resetError(name) {\n      var field = this._get(name);\n\n      if (field) {\n        delete field.errors; //清空错误\n\n        field.state = '';\n      }\n    } //trigger rerender\n\n  }, {\n    key: \"_reRender\",\n    value: function _reRender() {\n      if (this.com) {\n        if (!this.options.forceUpdate && this.com.setState) {\n          this.com.setState({});\n        } else if (this.com.forceUpdate) {\n          this.com.forceUpdate(); //forceUpdate 对性能有较大的影响，成指数上升\n        }\n      }\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(name) {\n      return name in this.fieldsMeta ? this.fieldsMeta[name] : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(com) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new this(com, options);\n    }\n  }, {\n    key: \"getUseField\",\n    value: function getUseField(_ref2) {\n      var _this14 = this;\n\n      var useState = _ref2.useState,\n          useMemo = _ref2.useMemo;\n      return function () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var _useState = useState(),\n            _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n            setState = _useState2[1];\n\n        var field = useMemo(function () {\n          return _this14.create({\n            setState: setState\n          }, options);\n        }, [setState]);\n        return field;\n      };\n    }\n  }]);\n  return Field;\n}();\n\nvar _default = Field;\nexports.default = _default;","map":{"version":3,"sources":["/Users/Chris/Project/lunch-order-backstage/node_modules/@alifd/field/lib/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_regenerator","_slicedToArray2","_asyncToGenerator2","_typeof2","_defineProperty2","_extends2","_classCallCheck2","_createClass2","_validate2","_utils","initMeta","state","valueName","trigger","Field","com","_this","options","arguments","length","undefined","warning","fieldsMeta","cachedBind","instance","instanceCount","values","processErrorMessage","afterValidateRerender","parseName","forceUpdate","scrollToFirstError","first","onChange","autoUnmount","autoValidate","forEach","m","bind","key","setOptions","init","name","_this2","fieldOption","rprops","id","initValue","_fieldOption$valueNam","_fieldOption$trigger","_fieldOption$rules","rules","_fieldOption$props","props","_fieldOption$getValue","getValueFromEvent","_fieldOption$getValue2","getValueFormatter","setValueFormatter","_fieldOption$autoVali","originalProps","defaultValueName","concat","toUpperCase","slice","defaultValue","field","_getInitMeta","disabled","Array","isArray","ref","setIn","cachedValue","getIn","_cachedValue","inputProps","_getCacheBind","_saveRef","rulesMap","mapValidateRules","_loop","action","actionRule","_len","args","_key","_callNativePropsEvent","apply","_validate","_ret","_len2","_key2","_updateFieldValue","_resetError","rule","_reRender","_len3","_key3","_len4","others","_key4","e","_get","fn","cache","_setCache","hander","_getCache","component","remove","setValue","Error","current","cnt","_this3","validate","abort","messages","errors","newErrors","newState","getErrorStrs","reRender","find","idx","getValue","getValues","names","_this4","allValues","setValues","_this5","fieldsValue","keys","fields","getNames","setError","err","setErrors","_this6","fieldsErrors","getError","getErrors","_this7","allErrors","f","getState","formatGetErrors","fieldNames","formattedErrors","hasOwnProperty","errorsObj","validateCallback","ns","cb","_this8","_getParams","getParams","callback","descriptor","hasRule","i","errorsGroup","fieldName","fieldErrors","push","message","formattedGetErrors","_i","_name","_field","_validatePromise","mark","_callee","_getParams2","_errors","results","callbackResults","wrap","_callee$","_context","prev","next","abrupt","validatePromise","sent","_getErrorsGroup","t0","stop","_x","_x2","_ref","_this9","_reset","backToDefault","_this10","changed","reset","resetToDefault","filter","_this11","deleteIn","addArrayValue","index","_len5","argv","_key5","_spliceArrayValue","deleteArrayValue","howmany","_this12","_len6","_key6","argc","offset","startIndex","listMap","keyReg","RegExp","replaceArgv","n","ret","exec","parseInt","l","item","from","to","replace","match","p1","offsetList","map","Number","list","sort","a","b","removeList","p","splice","spliceArray","keyMatch","_this13","reg","idxList","v","lastIdxList","parentName","parent","setState","create","getUseField","_ref2","_this14","useState","useMemo","_useState","_useState2","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _validate2 = _interopRequireDefault(require(\"@alifd/validate\"));\n\nvar _utils = require(\"./utils\");\n\nvar initMeta = {\n  state: '',\n  valueName: 'value',\n  trigger: 'onChange'\n};\n\nvar Field = /*#__PURE__*/function () {\n  function Field(com) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2.default)(this, Field);\n\n    if (!com) {\n      (0, _utils.warning)('`this` is missing in `Field`, you should use like `new Field(this)`');\n    }\n\n    this.com = com;\n    this.fieldsMeta = {};\n    this.cachedBind = {};\n    this.instance = {};\n    this.instanceCount = {}; // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.\n    // Also used caching values when using `parseName: true` before a field is initialized\n\n    this.values = (0, _extends2.default)({}, options.values);\n    this.processErrorMessage = options.processErrorMessage;\n    this.afterValidateRerender = options.afterValidateRerender;\n    this.options = (0, _extends2.default)({\n      parseName: false,\n      forceUpdate: false,\n      scrollToFirstError: true,\n      first: false,\n      onChange: function onChange() {},\n      autoUnmount: true,\n      autoValidate: true\n    }, options);\n    ['init', 'getValue', 'getValues', 'setValue', 'setValues', 'getError', 'getErrors', 'setError', 'setErrors', 'validateCallback', 'validatePromise', 'getState', 'reset', 'resetToDefault', 'remove', 'spliceArray', 'addArrayValue', 'deleteArrayValue', 'getNames'].forEach(function (m) {\n      _this[m] = _this[m].bind(_this);\n    });\n  }\n\n  (0, _createClass2.default)(Field, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      (0, _extends2.default)(this.options, options);\n    }\n    /**\n     * Controlled Component\n     * @param {String} name\n     * @param {Object} fieldOption\n     * @returns {Object} {value, onChange}\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(name) {\n      var _this2 = this;\n\n      var fieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rprops = arguments.length > 2 ? arguments[2] : undefined;\n      var id = fieldOption.id,\n          initValue = fieldOption.initValue,\n          _fieldOption$valueNam = fieldOption.valueName,\n          valueName = _fieldOption$valueNam === void 0 ? 'value' : _fieldOption$valueNam,\n          _fieldOption$trigger = fieldOption.trigger,\n          trigger = _fieldOption$trigger === void 0 ? 'onChange' : _fieldOption$trigger,\n          _fieldOption$rules = fieldOption.rules,\n          rules = _fieldOption$rules === void 0 ? [] : _fieldOption$rules,\n          _fieldOption$props = fieldOption.props,\n          props = _fieldOption$props === void 0 ? {} : _fieldOption$props,\n          _fieldOption$getValue = fieldOption.getValueFromEvent,\n          getValueFromEvent = _fieldOption$getValue === void 0 ? null : _fieldOption$getValue,\n          _fieldOption$getValue2 = fieldOption.getValueFormatter,\n          getValueFormatter = _fieldOption$getValue2 === void 0 ? getValueFromEvent : _fieldOption$getValue2,\n          setValueFormatter = fieldOption.setValueFormatter,\n          _fieldOption$autoVali = fieldOption.autoValidate,\n          autoValidate = _fieldOption$autoVali === void 0 ? true : _fieldOption$autoVali;\n      var parseName = this.options.parseName;\n\n      if (getValueFromEvent) {\n        (0, _utils.warning)('`getValueFromEvent` has been deprecated in `Field`, use `getValueFormatter` instead of it');\n      }\n\n      var originalProps = (0, _extends2.default)({}, props, rprops);\n      var defaultValueName = \"default\".concat(valueName[0].toUpperCase()).concat(valueName.slice(1));\n      var defaultValue;\n\n      if (typeof initValue !== 'undefined') {\n        defaultValue = initValue;\n      } else if (typeof originalProps[defaultValueName] !== 'undefined') {\n        // here use typeof, in case of defaultValue={0}\n        defaultValue = originalProps[defaultValueName];\n      } // get field from this.fieldsMeta or new one\n\n\n      var field = this._getInitMeta(name);\n\n      (0, _extends2.default)(field, {\n        valueName: valueName,\n        initValue: defaultValue,\n        disabled: 'disabled' in originalProps ? originalProps.disabled : false,\n        getValueFormatter: getValueFormatter,\n        setValueFormatter: setValueFormatter,\n        rules: Array.isArray(rules) ? rules : [rules],\n        ref: originalProps.ref\n      }); // Controlled Component, should always equal props.value\n\n      if (valueName in originalProps) {\n        field.value = originalProps[valueName]; // When rerendering set the values from props.value\n\n        if (parseName) {\n          this.values = (0, _utils.setIn)(this.values, name, field.value);\n        } else {\n          this.values[name] = field.value;\n        }\n      }\n      /**\n       * first init field (value not in field)\n       * should get field.value from this.values or defaultValue\n       */\n\n\n      if (!('value' in field)) {\n        if (parseName) {\n          var cachedValue = (0, _utils.getIn)(this.values, name);\n\n          if (typeof cachedValue !== 'undefined') {\n            field.value = cachedValue;\n          } else {\n            // save struct to this.values even defaultValue is undefiend\n            field.value = defaultValue;\n            this.values = (0, _utils.setIn)(this.values, name, field.value);\n          }\n        } else {\n          var _cachedValue = this.values[name];\n\n          if (typeof _cachedValue !== 'undefined') {\n            field.value = _cachedValue;\n          } else if (typeof defaultValue !== 'undefined') {\n            // should be same with parseName, but compatible with old versions\n            field.value = defaultValue;\n            this.values[name] = field.value;\n          }\n        }\n      } // Component props\n\n\n      var inputProps = (0, _defineProperty2.default)({\n        'data-meta': 'Field',\n        id: id || name,\n        ref: this._getCacheBind(name, \"\".concat(name, \"__ref\"), this._saveRef)\n      }, valueName, setValueFormatter ? setValueFormatter(field.value) : field.value);\n      var rulesMap = {};\n\n      if (this.options.autoValidate && autoValidate !== false) {\n        // trigger map in rules,\n        rulesMap = (0, _utils.mapValidateRules)(field.rules, trigger); // step1 : validate hooks\n\n        var _loop = function _loop(action) {\n          // skip default trigger, which will trigger in step2\n          if (action === trigger) {\n            return \"continue\";\n          }\n\n          var actionRule = rulesMap[action];\n\n          inputProps[action] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            _this2._callNativePropsEvent.apply(_this2, [action, originalProps].concat(args));\n\n            _this2._validate(name, actionRule, action);\n          };\n        };\n\n        for (var action in rulesMap) {\n          var _ret = _loop(action);\n\n          if (_ret === \"continue\") continue;\n        }\n      } // step2: onChange(trigger=onChange by default) hack\n\n\n      inputProps[trigger] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this2._updateFieldValue.apply(_this2, [name].concat(args)); // clear validate error\n\n\n        _this2._resetError(name);\n\n        _this2._callNativePropsEvent.apply(_this2, [trigger, originalProps].concat(args)); // call global onChange\n\n\n        _this2.options.onChange(name, field.value); // validate while onChange\n\n\n        var rule = rulesMap[trigger];\n        rule && _this2._validate(name, rule, trigger);\n\n        _this2._reRender();\n      };\n\n      delete originalProps[defaultValueName];\n      return (0, _extends2.default)({}, originalProps, inputProps);\n    }\n    /**\n     * call native event from props.onXx\n     * eg: props.onChange props.onBlur props.onFocus\n     */\n\n  }, {\n    key: \"_callNativePropsEvent\",\n    value: function _callNativePropsEvent(action, props) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      action in props && typeof props[action] === 'function' && props[action].apply(props, args);\n    }\n  }, {\n    key: \"_getInitMeta\",\n    value: function _getInitMeta(name) {\n      if (!(name in this.fieldsMeta)) {\n        this.fieldsMeta[name] = (0, _extends2.default)({}, initMeta);\n      }\n\n      return this.fieldsMeta[name];\n    }\n    /**\n     * update field.value and validate\n     */\n\n  }, {\n    key: \"_updateFieldValue\",\n    value: function _updateFieldValue(name) {\n      for (var _len4 = arguments.length, others = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        others[_key4 - 1] = arguments[_key4];\n      }\n\n      var e = others[0];\n\n      var field = this._get(name);\n\n      if (!field) {\n        return;\n      }\n\n      field.value = field.getValueFormatter ? field.getValueFormatter.apply(this, others) : (0, _utils.getValueFromEvent)(e);\n\n      if (this.options.parseName) {\n        this.values = (0, _utils.setIn)(this.values, name, field.value);\n      } else {\n        this.values[name] = field.value;\n      }\n    }\n    /**\n     * ref must always be the same function, or if not it will be triggerd every time.\n     * @param {String} name name of component\n     * @param {String} action key to find ref\n     * @param {Function} fn saveRef\n     */\n\n  }, {\n    key: \"_getCacheBind\",\n    value: function _getCacheBind(name, action, fn) {\n      var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n\n      if (!cache[action]) {\n        cache[action] = fn.bind(this, name);\n      }\n\n      return cache[action];\n    }\n  }, {\n    key: \"_setCache\",\n    value: function _setCache(name, action, hander) {\n      var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n      cache[action] = hander;\n    }\n  }, {\n    key: \"_getCache\",\n    value: function _getCache(name, action) {\n      var cache = this.cachedBind[name] || {};\n      return cache[action];\n    }\n    /**\n     * NOTE: saveRef is async function. it will be called after render\n     * @param {String} name name of component\n     * @param {Function} component ref\n     */\n\n  }, {\n    key: \"_saveRef\",\n    value: function _saveRef(name, component) {\n      var key = \"\".concat(name, \"_field\");\n      var autoUnmount = this.options.autoUnmount;\n\n      if (!component && autoUnmount) {\n        // more than one component, do nothing\n        this.instanceCount[name] && this.instanceCount[name]--;\n\n        if (this.instanceCount[name] > 0) {\n          return;\n        } // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)\n        // while type changed, B will render before A unmount. so we should cached value for B\n        // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render\n        // 1. _saveRef(A, null)\n\n\n        var cache = this.fieldsMeta[name];\n        cache && this._setCache(name, key, cache); // after destroy, delete data\n\n        delete this.instance[name];\n        this.remove(name);\n        return;\n      } // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)\n\n\n      if (autoUnmount && !this.fieldsMeta[name] && this._getCache(name, key)) {\n        this.fieldsMeta[name] = this._getCache(name, key);\n        this.setValue(name, this.fieldsMeta[name] && this.fieldsMeta[name].value, false);\n      } // only one time here\n\n\n      var field = this._get(name);\n\n      if (field) {\n        var ref = field.ref;\n\n        if (ref) {\n          if (typeof ref === 'string') {\n            throw new Error(\"can not set string ref for \".concat(name));\n          } else if (typeof ref === 'function') {\n            ref(component);\n          } else if ((0, _typeof2.default)(ref) === 'object' && 'current' in ref) {\n            // while ref = React.createRef() ref={ current: null}\n            ref.current = component;\n          }\n        } // mount\n\n\n        if (autoUnmount && component) {\n          var cnt = this.instanceCount[name];\n\n          if (!cnt) {\n            cnt = 0;\n          }\n\n          this.instanceCount[name] = cnt + 1;\n        }\n\n        this.instance[name] = component;\n      }\n    }\n    /**\n     * validate one Component\n     * @param {String} name name of Component\n     * @param {Array} rule\n     * @param {String} trigger onChange/onBlur/onItemClick/...\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate(name, rule, trigger) {\n      var _this3 = this;\n\n      var field = this._get(name);\n\n      if (!field) {\n        return;\n      }\n\n      var value = field.value;\n      field.state = 'loading';\n\n      var validate = this._getCache(name, trigger);\n\n      if (validate && typeof validate.abort === 'function') {\n        validate.abort();\n      }\n\n      validate = new _validate2.default((0, _defineProperty2.default)({}, name, rule), {\n        messages: this.options.messages\n      });\n\n      this._setCache(name, trigger, validate);\n\n      validate.validate((0, _defineProperty2.default)({}, name, value), function (errors) {\n        var newErrors, newState;\n\n        if (errors && errors.length) {\n          newErrors = (0, _utils.getErrorStrs)(errors, _this3.processErrorMessage);\n          newState = 'error';\n        } else {\n          newErrors = [];\n          newState = 'success';\n        }\n\n        var reRender = false; // only status or errors changed, Rerender\n\n        if (newState !== field.state || !field.errors || newErrors.length !== field.errors.length || newErrors.find(function (e, idx) {\n          return e !== field.errors[idx];\n        })) {\n          reRender = true;\n        }\n\n        field.errors = newErrors;\n        field.state = newState;\n        reRender && _this3._reRender();\n      });\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(name) {\n      if (this.options.parseName) {\n        return (0, _utils.getIn)(this.values, name);\n      }\n\n      return this.values[name];\n    }\n    /**\n     * 1. get values by names.\n     * 2. If no names passed, return shallow copy of `field.values`\n     * @param {Array} names\n     */\n\n  }, {\n    key: \"getValues\",\n    value: function getValues(names) {\n      var _this4 = this;\n\n      var allValues = {};\n\n      if (names && names.length) {\n        names.forEach(function (name) {\n          allValues[name] = _this4.getValue(name);\n        });\n      } else {\n        (0, _extends2.default)(allValues, this.values);\n      }\n\n      return allValues;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(name, value) {\n      var reRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (name in this.fieldsMeta) {\n        this.fieldsMeta[name].value = value;\n      }\n\n      if (this.options.parseName) {\n        this.values = (0, _utils.setIn)(this.values, name, value);\n      } else {\n        this.values[name] = value;\n      }\n\n      reRender && this._reRender();\n    }\n  }, {\n    key: \"setValues\",\n    value: function setValues() {\n      var _this5 = this;\n\n      var fieldsValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.options.parseName) {\n        Object.keys(fieldsValue).forEach(function (name) {\n          _this5.setValue(name, fieldsValue[name], false);\n        });\n      } else {\n        // NOTE: this is a shallow merge\n        // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}\n        this.values = (0, _extends2.default)({}, this.values, fieldsValue);\n        var fields = this.getNames();\n        fields.forEach(function (name) {\n          var value = (0, _utils.getIn)(_this5.values, name);\n\n          if (value !== undefined) {\n            // copy over values that are in this.values\n            _this5.fieldsMeta[name].value = value;\n          } else {\n            // because of shallow merge\n            // if no value then copy values from fieldsMeta to keep initialized component data\n            _this5.values = (0, _utils.setIn)(_this5.values, name, _this5.fieldsMeta[name].value);\n          }\n        });\n      }\n\n      reRender && this._reRender();\n    }\n  }, {\n    key: \"setError\",\n    value: function setError(name, errors) {\n      var err = Array.isArray(errors) ? errors : errors ? [errors] : [];\n\n      if (name in this.fieldsMeta) {\n        this.fieldsMeta[name].errors = err;\n      } else {\n        this.fieldsMeta[name] = {\n          errors: err\n        };\n      }\n\n      if (this.fieldsMeta[name].errors && this.fieldsMeta[name].errors.length > 0) {\n        this.fieldsMeta[name].state = 'error';\n      } else {\n        this.fieldsMeta[name].state = '';\n      }\n\n      this._reRender();\n    }\n  }, {\n    key: \"setErrors\",\n    value: function setErrors() {\n      var _this6 = this;\n\n      var fieldsErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(fieldsErrors).forEach(function (name) {\n        _this6.setError(name, fieldsErrors[name]);\n      });\n    }\n  }, {\n    key: \"getError\",\n    value: function getError(name) {\n      var field = this._get(name);\n\n      if (field && field.errors && field.errors.length) {\n        return field.errors;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getErrors\",\n    value: function getErrors(names) {\n      var _this7 = this;\n\n      var fields = names || this.getNames();\n      var allErrors = {};\n      fields.forEach(function (f) {\n        allErrors[f] = _this7.getError(f);\n      });\n      return allErrors;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState(name) {\n      var field = this._get(name);\n\n      if (field && field.state) {\n        return field.state;\n      }\n\n      return '';\n    }\n    /**\n     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate\n     * @param {Array} fieldNames\n     * @return {Object || null} map of inputs and their errors\n     */\n\n  }, {\n    key: \"formatGetErrors\",\n    value: function formatGetErrors(fieldNames) {\n      var errors = this.getErrors(fieldNames);\n      var formattedErrors = null;\n\n      for (var field in errors) {\n        if (errors.hasOwnProperty(field) && errors[field]) {\n          var errorsObj = errors[field];\n\n          if (!formattedErrors) {\n            formattedErrors = {};\n          }\n\n          formattedErrors[field] = {\n            errors: errorsObj\n          };\n        }\n      }\n\n      return formattedErrors;\n    }\n    /**\n     * validate by trigger\n     * @param {Array} ns names\n     * @param {Function} cb callback after validate\n     */\n\n  }, {\n    key: \"validateCallback\",\n    value: function validateCallback(ns, cb) {\n      var _this8 = this;\n\n      var _getParams = (0, _utils.getParams)(ns, cb),\n          names = _getParams.names,\n          callback = _getParams.callback;\n\n      var fieldNames = names || this.getNames();\n      var descriptor = {};\n      var values = {};\n      var hasRule = false;\n\n      for (var i = 0; i < fieldNames.length; i++) {\n        var name = fieldNames[i];\n\n        var field = this._get(name);\n\n        if (!field) {\n          continue;\n        }\n\n        if (field.rules && field.rules.length) {\n          descriptor[name] = field.rules;\n          values[name] = this.getValue(name);\n          hasRule = true; // clear error\n\n          field.errors = [];\n          field.state = '';\n        }\n      }\n\n      if (!hasRule) {\n        var errors = this.formatGetErrors(fieldNames);\n        callback && callback(errors, this.getValues(names ? fieldNames : []));\n        return;\n      }\n\n      var validate = new _validate2.default(descriptor, {\n        first: this.options.first,\n        messages: this.options.messages\n      });\n      validate.validate(values, function (errors) {\n        var errorsGroup = null;\n\n        if (errors && errors.length) {\n          errorsGroup = {};\n          errors.forEach(function (e) {\n            var fieldName = e.field;\n\n            if (!errorsGroup[fieldName]) {\n              errorsGroup[fieldName] = {\n                errors: []\n              };\n            }\n\n            var fieldErrors = errorsGroup[fieldName].errors;\n            fieldErrors.push(e.message);\n          });\n        }\n\n        if (errorsGroup) {\n          // update error in every Field\n          Object.keys(errorsGroup).forEach(function (i) {\n            var field = _this8._get(i);\n\n            if (field) {\n              field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this8.processErrorMessage);\n              field.state = 'error';\n            }\n          });\n        }\n\n        var formattedGetErrors = _this8.formatGetErrors(fieldNames);\n\n        if (formattedGetErrors) {\n          errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);\n        } // update to success which has no error\n\n\n        for (var _i = 0; _i < fieldNames.length; _i++) {\n          var _name = fieldNames[_i];\n\n          var _field = _this8._get(_name);\n\n          if (_field && _field.rules && !(errorsGroup && _name in errorsGroup)) {\n            _field.state = 'success';\n          }\n        } // eslint-disable-next-line callback-return\n\n\n        callback && callback(errorsGroup, _this8.getValues(names ? fieldNames : []));\n\n        _this8._reRender();\n\n        if (typeof _this8.afterValidateRerender === 'function') {\n          _this8.afterValidateRerender({\n            errorsGroup: errorsGroup,\n            options: _this8.options,\n            instance: _this8.instance\n          });\n        }\n      });\n    }\n    /**\n     * validate by trigger - Promise version\n     * NOTES:\n     * - `afterValidateRerender` is not called in `validatePromise`. The rerender is called just before this function\n     *      returns a promise, so use the returned promise to call any after rerender logic.\n     *\n     * @param {Array} ns names\n     * @param {Function} cb (Optional) callback after validate, must return a promise or a value\n     *                  - ({errors, values}) => Promise({errors, values}) | {errors, values}\n     * @returns {Promise} - resolves with {errors, values}\n     */\n\n  }, {\n    key: \"validatePromise\",\n    value: function () {\n      var _validatePromise = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(ns, cb) {\n        var _getParams2, names, callback, fieldNames, descriptor, values, hasRule, i, name, field, _errors, validate, results, errors, errorsGroup, callbackResults;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _getParams2 = (0, _utils.getParams)(ns, cb), names = _getParams2.names, callback = _getParams2.callback;\n                fieldNames = names || this.getNames();\n                descriptor = {};\n                values = {};\n                hasRule = false;\n                i = 0;\n\n              case 6:\n                if (!(i < fieldNames.length)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                name = fieldNames[i];\n                field = this._get(name);\n\n                if (field) {\n                  _context.next = 11;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 12);\n\n              case 11:\n                if (field.rules && field.rules.length) {\n                  descriptor[name] = field.rules;\n                  values[name] = this.getValue(name);\n                  hasRule = true; // clear error\n\n                  field.errors = [];\n                  field.state = '';\n                }\n\n              case 12:\n                i++;\n                _context.next = 6;\n                break;\n\n              case 15:\n                if (hasRule) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _errors = this.formatGetErrors(fieldNames);\n\n                if (!callback) {\n                  _context.next = 21;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", callback({\n                  errors: _errors,\n                  values: this.getValues(names ? fieldNames : [])\n                }));\n\n              case 21:\n                return _context.abrupt(\"return\", {\n                  errors: _errors,\n                  values: this.getValues(names ? fieldNames : [])\n                });\n\n              case 22:\n                validate = new _validate2.default(descriptor, {\n                  first: this.options.first,\n                  messages: this.options.messages\n                });\n                _context.next = 25;\n                return validate.validatePromise(values);\n\n              case 25:\n                results = _context.sent;\n                errors = results && results.errors || [];\n                errorsGroup = this._getErrorsGroup({\n                  errors: errors,\n                  fieldNames: fieldNames\n                });\n                callbackResults = {\n                  errors: errorsGroup,\n                  values: this.getValues(names ? fieldNames : [])\n                };\n                _context.prev = 29;\n\n                if (!callback) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _context.next = 33;\n                return callback(callbackResults);\n\n              case 33:\n                callbackResults = _context.sent;\n\n              case 34:\n                _context.next = 39;\n                break;\n\n              case 36:\n                _context.prev = 36;\n                _context.t0 = _context[\"catch\"](29);\n                return _context.abrupt(\"return\", _context.t0);\n\n              case 39:\n                this._reRender();\n\n                return _context.abrupt(\"return\", callbackResults);\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[29, 36]]);\n      }));\n\n      function validatePromise(_x, _x2) {\n        return _validatePromise.apply(this, arguments);\n      }\n\n      return validatePromise;\n    }()\n  }, {\n    key: \"_getErrorsGroup\",\n    value: function _getErrorsGroup(_ref) {\n      var _this9 = this;\n\n      var errors = _ref.errors,\n          fieldNames = _ref.fieldNames;\n      var errorsGroup = null;\n\n      if (errors && errors.length) {\n        errorsGroup = {};\n        errors.forEach(function (e) {\n          var fieldName = e.field;\n\n          if (!errorsGroup[fieldName]) {\n            errorsGroup[fieldName] = {\n              errors: []\n            };\n          }\n\n          var fieldErrors = errorsGroup[fieldName].errors;\n          fieldErrors.push(e.message);\n        });\n      }\n\n      if (errorsGroup) {\n        // update error in every Field\n        Object.keys(errorsGroup).forEach(function (i) {\n          var field = _this9._get(i);\n\n          if (field) {\n            field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this9.processErrorMessage);\n            field.state = 'error';\n          }\n        });\n      }\n\n      var formattedGetErrors = this.formatGetErrors(fieldNames);\n\n      if (formattedGetErrors) {\n        errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);\n      } // update to success which has no error\n\n\n      for (var i = 0; i < fieldNames.length; i++) {\n        var name = fieldNames[i];\n\n        var field = this._get(name);\n\n        if (field && field.rules && !(errorsGroup && name in errorsGroup)) {\n          field.state = 'success';\n        }\n      }\n\n      return errorsGroup;\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(ns, backToDefault) {\n      var _this10 = this;\n\n      if (typeof ns === 'string') {\n        ns = [ns];\n      }\n\n      var changed = false;\n      var names = ns || Object.keys(this.fieldsMeta);\n\n      if (!ns) {\n        this.values = {};\n      }\n\n      names.forEach(function (name) {\n        var field = _this10._get(name);\n\n        if (field) {\n          changed = true;\n          field.value = backToDefault ? field.initValue : undefined;\n          field.state = '';\n          delete field.errors;\n          delete field.rules;\n          delete field.rulesMap;\n\n          if (_this10.options.parseName) {\n            _this10.values = (0, _utils.setIn)(_this10.values, name, field.value);\n          } else {\n            _this10.values[name] = field.value;\n          }\n        }\n      });\n\n      if (changed) {\n        this._reRender();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(ns) {\n      this._reset(ns, false);\n    }\n  }, {\n    key: \"resetToDefault\",\n    value: function resetToDefault(ns) {\n      this._reset(ns, true);\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      var fieldsMeta = this.fieldsMeta;\n      return Object.keys(fieldsMeta).filter(function () {\n        return true;\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ns) {\n      var _this11 = this;\n\n      if (typeof ns === 'string') {\n        ns = [ns];\n      }\n\n      if (!ns) {\n        this.values = {};\n      }\n\n      var names = ns || Object.keys(this.fieldsMeta);\n      names.forEach(function (name) {\n        if (name in _this11.fieldsMeta) {\n          delete _this11.fieldsMeta[name];\n        }\n\n        if (_this11.options.parseName) {\n          _this11.values = (0, _utils.deleteIn)(_this11.values, name);\n        } else {\n          delete _this11.values[name];\n        }\n      });\n    }\n  }, {\n    key: \"addArrayValue\",\n    value: function addArrayValue(key, index) {\n      for (var _len5 = arguments.length, argv = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        argv[_key5 - 2] = arguments[_key5];\n      }\n\n      return this._spliceArrayValue.apply(this, [key, index, 0].concat(argv));\n    }\n  }, {\n    key: \"deleteArrayValue\",\n    value: function deleteArrayValue(key, index) {\n      var howmany = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return this._spliceArrayValue(key, index, howmany);\n    }\n    /**\n     * splice array\n     * @param {String} key\n     * @param {Number} startIndex\n     * @param {Number} howmany\n     * @param {Array} argv\n     * @param {*} value\n     */\n\n  }, {\n    key: \"_spliceArrayValue\",\n    value: function _spliceArrayValue(key, index, howmany) {\n      var _this12 = this;\n\n      for (var _len6 = arguments.length, argv = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n        argv[_key6 - 3] = arguments[_key6];\n      }\n\n      var argc = argv.length;\n      var offset = howmany - argc; // how the reset fieldMeta move\n\n      var startIndex = index + howmany; // 计算起点\n\n      /**\n       * eg: call _spliceArrayValue('key', 1) to delete 'key.1':\n       *   case 1: names=['key.0', 'key.1']; delete 'key.1';\n       *   case 2: names=['key.0', 'key.1', 'key.2']; key.1= key.2; delete key.2;\n       *   case 3: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'\n       * eg: call _spliceArrayValue('key', 1, item) to add 'key.1':\n       *   case 1: names=['key.0']; add 'key.1' = item;\n       *   case 2: names=['key.0', 'key.1']; key.2= key.1; delete key.1; add key.1 = item;\n       */\n\n      var listMap = {}; // eg: {1:[{from: 'key.2.name', to: 'key.1.name'}, {from: 'key.2.email', to: 'key.1.email'}]}\n\n      var keyReg = new RegExp(\"^(\".concat(key, \".)(\\\\d+)\"));\n      var replaceArgv = [];\n      var names = this.getNames(); // logic of offset fix begin\n\n      names.forEach(function (n) {\n        var ret = keyReg.exec(n);\n\n        if (ret) {\n          var idx = parseInt(ret[2]); // get index of 'key.0.name'\n\n          if (idx >= startIndex) {\n            var l = listMap[idx];\n            var item = {\n              from: n,\n              to: n.replace(keyReg, function (match, p1) {\n                return \"\".concat(p1).concat(idx - offset);\n              })\n            };\n\n            if (!l) {\n              listMap[idx] = [item];\n            } else {\n              l.push(item);\n            }\n          } // in case of offsetList.length = 0, eg: delete last element\n\n\n          if (offset > 0 && idx >= index && idx < index + howmany) {\n            replaceArgv.push(n);\n          }\n        }\n      }); // sort with index eg: [{index:1, list: [{from: 'key.2.name', to: 'key.1.name'}]}, {index:2, list: [...]}]\n\n      var offsetList = Object.keys(listMap).map(function (i) {\n        return {\n          index: Number(i),\n          list: listMap[i]\n        };\n      }).sort(function (a, b) {\n        return offset > 0 ? a.index - b.index : b.index - a.index;\n      });\n      offsetList.forEach(function (l) {\n        var list = l.list;\n        list.forEach(function (i) {\n          _this12.fieldsMeta[i.to] = _this12.fieldsMeta[i.from];\n        });\n      }); // delete copy data\n\n      if (offsetList.length > 0) {\n        var removeList = offsetList.slice(offsetList.length - (offset < 0 ? -offset : offset), offsetList.length);\n        removeList.forEach(function (item) {\n          item.list.forEach(function (i) {\n            delete _this12.fieldsMeta[i.from];\n          });\n        });\n      } else {\n        // will get from this.values while rerender\n        replaceArgv.forEach(function (i) {\n          delete _this12.fieldsMeta[i];\n        });\n      }\n\n      var p = this.getValue(key);\n\n      if (p) {\n        p.splice.apply(p, [index, howmany].concat(argv));\n      }\n\n      this._reRender();\n    }\n    /**\n     * splice in a Array [deprecated]\n     * @param {String} keyMatch like name.{index}\n     * @param {Number} startIndex index\n     */\n\n  }, {\n    key: \"spliceArray\",\n    value: function spliceArray(keyMatch, startIndex, howmany) {\n      var _this13 = this;\n\n      if (keyMatch.match(/{index}$/) === -1) {\n        (0, _utils.warning)('key should match /{index}$/');\n        return;\n      } // regex to match field names in the same target array\n\n\n      var reg = keyMatch.replace('{index}', '(\\\\d+)');\n      var keyReg = new RegExp(\"^\".concat(reg));\n      var listMap = {};\n      /**\n       * keyMatch='key.{index}'\n       * case 1: names=['key.0', 'key.1'], should delete 'key.1'\n       * case 2: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'\n       */\n\n      var names = this.getNames();\n      names.forEach(function (n) {\n        // is name in the target array?\n        var ret = keyReg.exec(n);\n\n        if (ret) {\n          var index = parseInt(ret[1]);\n\n          if (index > startIndex) {\n            var l = listMap[index];\n            var item = {\n              from: n,\n              to: \"\".concat(keyMatch.replace('{index}', index - 1)).concat(n.replace(ret[0], ''))\n            };\n\n            if (!l) {\n              listMap[index] = [item];\n            } else {\n              l.push(item);\n            }\n          }\n        }\n      });\n      var idxList = Object.keys(listMap).map(function (i) {\n        return {\n          index: Number(i),\n          list: listMap[i]\n        };\n      }).sort(function (a, b) {\n        return a.index < b.index;\n      }); // should be continuous array\n\n      if (idxList.length > 0 && idxList[0].index === startIndex + 1) {\n        idxList.forEach(function (l) {\n          var list = l.list;\n          list.forEach(function (i) {\n            var v = _this13.getValue(i.from); // get index value\n\n\n            _this13.setValue(i.to, v, false); // set value to index - 1\n\n          });\n        });\n        var lastIdxList = idxList[idxList.length - 1];\n        lastIdxList.list.forEach(function (i) {\n          _this13.remove(i.from);\n        });\n        var parentName = keyMatch.replace('.{index}', '');\n        parentName = parentName.replace('[{index}]', '');\n        var parent = this.getValue(parentName);\n\n        if (parent) {\n          // if parseName=true then parent is an Array object but does not know an element was removed\n          // this manually decrements the array length\n          parent.length--;\n        }\n      }\n    }\n  }, {\n    key: \"_resetError\",\n    value: function _resetError(name) {\n      var field = this._get(name);\n\n      if (field) {\n        delete field.errors; //清空错误\n\n        field.state = '';\n      }\n    } //trigger rerender\n\n  }, {\n    key: \"_reRender\",\n    value: function _reRender() {\n      if (this.com) {\n        if (!this.options.forceUpdate && this.com.setState) {\n          this.com.setState({});\n        } else if (this.com.forceUpdate) {\n          this.com.forceUpdate(); //forceUpdate 对性能有较大的影响，成指数上升\n        }\n      }\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(name) {\n      return name in this.fieldsMeta ? this.fieldsMeta[name] : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(com) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new this(com, options);\n    }\n  }, {\n    key: \"getUseField\",\n    value: function getUseField(_ref2) {\n      var _this14 = this;\n\n      var useState = _ref2.useState,\n          useMemo = _ref2.useMemo;\n      return function () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var _useState = useState(),\n            _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n            setState = _useState2[1];\n\n        var field = useMemo(function () {\n          return _this14.create({\n            setState: setState\n          }, options);\n        }, [setState]);\n        return field;\n      };\n    }\n  }]);\n  return Field;\n}();\n\nvar _default = Field;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}