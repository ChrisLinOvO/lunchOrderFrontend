{"ast":null,"code":"import { isPromise } from './object';\n/**\n * 一个空方法，返回入参本身或空对象\n */\n\nexport var noop = function noop() {};\n/**\n * 一个空方法，返回false\n */\n\nexport var prevent = function prevent() {\n  return false;\n};\n/**\n * 将N个方法合并为一个链式调用的方法\n * @return {Function}     合并后的方法\n * 参考 https://github.com/react-component/util/\n *\n * @example\n * func.makeChain(this.handleChange, this.props.onChange);\n */\n\nexport function makeChain() {\n  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function chainedFunction() {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    for (var i = 0, j = fns.length; i < j; i++) {\n      if (fns[i] && fns[i].apply) {\n        fns[i].apply(this, args);\n      }\n    }\n  };\n}\n/**\n * 批量改变方法的上下文\n * 此方法在react组件中很有用，在constructor中批量将组件上的方法执行上下文绑定到组件本身\n * 注意：用bind改变函数运行的上下文只会生效一次\n * @param  {Object} ctx 方法挂载的对象以及执行的上下文\n * @param  {Array<String>} fns 方法名列表\n *\n * @example\n * func.bindCtx(this, ['handleClick', 'handleChange']);\n */\n\nexport function bindCtx(ctx, fns, ns) {\n  if (typeof fns === 'string') {\n    fns = [fns];\n  } // 方法的挂载空间，如果不传，默认与ctx相同\n\n\n  ns = ns || ctx;\n  fns.forEach(function (fnName) {\n    // 这里不要添加空方法判断，由调用者保证正确性，否则出了问题无法排查\n    ns[fnName] = ns[fnName].bind(ctx);\n  });\n}\n/**\n * 用于执行回调方法后的逻辑\n * @param  {*} ret            回调方法执行结果\n * @param  {Function} success 执行结果返回非false的回调\n * @param  {Function} [failure=noop] 执行结果返回false的回调\n */\n\nexport function promiseCall(ret, success) {\n  var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n  if (isPromise(ret)) {\n    return ret.then(function (result) {\n      success(result);\n      return result;\n    }).catch(function (e) {\n      failure(e); // throw e;\n    });\n  }\n\n  return ret !== false ? success(ret) : failure(ret);\n}\n/**\n * 方法调用，如果obj对象中存在名为method的方法则调用该方法\n * @param {Object} target 目标对象\n * @param {string} method 方法名\n * @param {Array} args 函数参数列表\n * @returns {*} 函数返回值 如果不存在返回undefined\n */\n\nexport function invoke(target, method, args) {\n  var func = target && method in target ? target[method] : undefined;\n  return func && func.apply(undefined, args);\n}\nexport function renderNode(render, defaultRender) {\n  var renderProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var r = render !== undefined ? render : defaultRender;\n\n  if (renderProps && !Array.isArray(renderProps)) {\n    renderProps = [renderProps];\n  }\n\n  return typeof r === 'function' ? r.apply(undefined, renderProps) : r;\n}","map":{"version":3,"sources":["/Users/Chris/Project/lunch-order-backstage/node_modules/@alifd/next/es/util/func.js"],"names":["isPromise","noop","prevent","makeChain","_len","arguments","length","fns","Array","_key","chainedFunction","_len2","args","_key2","i","j","apply","bindCtx","ctx","ns","forEach","fnName","bind","promiseCall","ret","success","failure","undefined","then","result","catch","e","invoke","target","method","func","renderNode","render","defaultRender","renderProps","r","isArray"],"mappings":"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","sourcesContent":["import { isPromise } from './object';\n\n/**\n * 一个空方法，返回入参本身或空对象\n */\nexport var noop = function noop() {};\n\n/**\n * 一个空方法，返回false\n */\nexport var prevent = function prevent() {\n    return false;\n};\n\n/**\n * 将N个方法合并为一个链式调用的方法\n * @return {Function}     合并后的方法\n * 参考 https://github.com/react-component/util/\n *\n * @example\n * func.makeChain(this.handleChange, this.props.onChange);\n */\nexport function makeChain() {\n    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n        fns[_key] = arguments[_key];\n    }\n\n    if (fns.length === 1) {\n        return fns[0];\n    }\n\n    return function chainedFunction() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        for (var i = 0, j = fns.length; i < j; i++) {\n            if (fns[i] && fns[i].apply) {\n                fns[i].apply(this, args);\n            }\n        }\n    };\n}\n\n/**\n * 批量改变方法的上下文\n * 此方法在react组件中很有用，在constructor中批量将组件上的方法执行上下文绑定到组件本身\n * 注意：用bind改变函数运行的上下文只会生效一次\n * @param  {Object} ctx 方法挂载的对象以及执行的上下文\n * @param  {Array<String>} fns 方法名列表\n *\n * @example\n * func.bindCtx(this, ['handleClick', 'handleChange']);\n */\nexport function bindCtx(ctx, fns, ns) {\n    if (typeof fns === 'string') {\n        fns = [fns];\n    }\n\n    // 方法的挂载空间，如果不传，默认与ctx相同\n    ns = ns || ctx;\n\n    fns.forEach(function (fnName) {\n        // 这里不要添加空方法判断，由调用者保证正确性，否则出了问题无法排查\n        ns[fnName] = ns[fnName].bind(ctx);\n    });\n}\n\n/**\n * 用于执行回调方法后的逻辑\n * @param  {*} ret            回调方法执行结果\n * @param  {Function} success 执行结果返回非false的回调\n * @param  {Function} [failure=noop] 执行结果返回false的回调\n */\nexport function promiseCall(ret, success) {\n    var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n    if (isPromise(ret)) {\n        return ret.then(function (result) {\n            success(result);\n            return result;\n        }).catch(function (e) {\n            failure(e);\n            // throw e;\n        });\n    }\n\n    return ret !== false ? success(ret) : failure(ret);\n}\n\n/**\n * 方法调用，如果obj对象中存在名为method的方法则调用该方法\n * @param {Object} target 目标对象\n * @param {string} method 方法名\n * @param {Array} args 函数参数列表\n * @returns {*} 函数返回值 如果不存在返回undefined\n */\nexport function invoke(target, method, args) {\n    var func = target && method in target ? target[method] : undefined;\n    return func && func.apply(undefined, args);\n}\n\nexport function renderNode(render, defaultRender) {\n    var renderProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var r = render !== undefined ? render : defaultRender;\n\n    if (renderProps && !Array.isArray(renderProps)) {\n        renderProps = [renderProps];\n    }\n    return typeof r === 'function' ? r.apply(undefined, renderProps) : r;\n}"]},"metadata":{},"sourceType":"module"}